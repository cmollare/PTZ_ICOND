<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<title>opencv: /home/christophe/src/OpenCV-2.2.0/modules/core/include/opencv2/core/core.hpp~ File Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css"/>
</head>
<body onload='searchBox.OnSelectItem(0);'>
<!-- Generated by Doxygen 1.7.4 -->
<script type="text/javascript"><!--
var searchBox = new SearchBox("searchBox", "search",false,'Search');
--></script>
<div id="top">
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td style="padding-left: 0.5em;">
   <div id="projectname">opencv&#160;<span id="projectnumber">2.2.0</span></div>
  </td>
 </tr>
 </tbody>
</table>
</div>
  <div id="navrow1" class="tabs">
    <ul class="tablist">
      <li><a href="index.html"><span>Main&#160;Page</span></a></li>
      <li><a href="pages.html"><span>Related&#160;Pages</span></a></li>
      <li><a href="namespaces.html"><span>Namespaces</span></a></li>
      <li><a href="annotated.html"><span>Classes</span></a></li>
      <li class="current"><a href="files.html"><span>Files</span></a></li>
      <li id="searchli">
        <div id="MSearchBox" class="MSearchBoxInactive">
        <span class="left">
          <img id="MSearchSelect" src="search/mag_sel.png"
               onmouseover="return searchBox.OnSearchSelectShow()"
               onmouseout="return searchBox.OnSearchSelectHide()"
               alt=""/>
          <input type="text" id="MSearchField" value="Search" accesskey="S"
               onfocus="searchBox.OnSearchFieldFocus(true)" 
               onblur="searchBox.OnSearchFieldFocus(false)" 
               onkeyup="searchBox.OnSearchFieldChange(event)"/>
          </span><span class="right">
            <a id="MSearchClose" href="javascript:searchBox.CloseResultsWindow()"><img id="MSearchCloseImg" border="0" src="search/close.png" alt=""/></a>
          </span>
        </div>
      </li>
    </ul>
  </div>
  <div id="navrow2" class="tabs2">
    <ul class="tablist">
      <li><a href="files.html"><span>File&#160;List</span></a></li>
      <li><a href="globals.html"><span>File&#160;Members</span></a></li>
    </ul>
  </div>
</div>
<div class="header">
  <div class="summary">
<a href="#nested-classes">Classes</a> &#124;
<a href="#namespaces">Namespaces</a> &#124;
<a href="#define-members">Defines</a> &#124;
<a href="#enum-members">Enumerations</a> &#124;
<a href="#func-members">Functions</a>  </div>
  <div class="headertitle">
<div class="title">/home/christophe/src/OpenCV-2.2.0/modules/core/include/opencv2/core/core.hpp~ File Reference</div>  </div>
</div>
<div class="contents">
<table class="memberdecls">
<tr><td colspan="2"><h2><a name="nested-classes"></a>
Classes</h2></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcv_1_1Allocator.html">cv::Allocator&lt; _Tp &gt;</a></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcv_1_1AutoBuffer.html">cv::AutoBuffer&lt; _Tp, fixed_size &gt;</a></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcv_1_1Complex.html">cv::Complex&lt; _Tp &gt;</a></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcv_1_1DataDepth.html">cv::DataDepth&lt; _Tp &gt;</a></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcv_1_1DataDepth_3_01__Tp_01_5_01_4.html">cv::DataDepth&lt; _Tp * &gt;</a></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcv_1_1DataDepth_3_01bool_01_4.html">cv::DataDepth&lt; bool &gt;</a></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcv_1_1DataDepth_3_01char_01_4.html">cv::DataDepth&lt; char &gt;</a></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcv_1_1DataDepth_3_01double_01_4.html">cv::DataDepth&lt; double &gt;</a></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcv_1_1DataDepth_3_01float_01_4.html">cv::DataDepth&lt; float &gt;</a></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcv_1_1DataDepth_3_01int_01_4.html">cv::DataDepth&lt; int &gt;</a></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcv_1_1DataDepth_3_01schar_01_4.html">cv::DataDepth&lt; schar &gt;</a></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcv_1_1DataDepth_3_01short_01_4.html">cv::DataDepth&lt; short &gt;</a></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcv_1_1DataDepth_3_01uchar_01_4.html">cv::DataDepth&lt; uchar &gt;</a></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcv_1_1DataDepth_3_01unsigned_01_4.html">cv::DataDepth&lt; unsigned &gt;</a></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcv_1_1DataDepth_3_01ushort_01_4.html">cv::DataDepth&lt; ushort &gt;</a></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcv_1_1DataType.html">cv::DataType&lt; _Tp &gt;</a></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcv_1_1DataType_3_01bool_01_4.html">cv::DataType&lt; bool &gt;</a></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcv_1_1DataType_3_01char_01_4.html">cv::DataType&lt; char &gt;</a></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcv_1_1DataType_3_01Complex_3_01__Tp_01_4_01_4.html">cv::DataType&lt; Complex&lt; _Tp &gt; &gt;</a></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcv_1_1DataType_3_01double_01_4.html">cv::DataType&lt; double &gt;</a></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcv_1_1DataType_3_01float_01_4.html">cv::DataType&lt; float &gt;</a></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcv_1_1DataType_3_01int_01_4.html">cv::DataType&lt; int &gt;</a></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcv_1_1DataType_3_01Point3___3_01__Tp_01_4_01_4.html">cv::DataType&lt; Point3_&lt; _Tp &gt; &gt;</a></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcv_1_1DataType_3_01Point___3_01__Tp_01_4_01_4.html">cv::DataType&lt; Point_&lt; _Tp &gt; &gt;</a></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcv_1_1DataType_3_01Range_01_4.html">cv::DataType&lt; Range &gt;</a></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcv_1_1DataType_3_01Rect___3_01__Tp_01_4_01_4.html">cv::DataType&lt; Rect_&lt; _Tp &gt; &gt;</a></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcv_1_1DataType_3_01Scalar___3_01__Tp_01_4_01_4.html">cv::DataType&lt; Scalar_&lt; _Tp &gt; &gt;</a></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcv_1_1DataType_3_01schar_01_4.html">cv::DataType&lt; schar &gt;</a></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcv_1_1DataType_3_01short_01_4.html">cv::DataType&lt; short &gt;</a></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcv_1_1DataType_3_01Size___3_01__Tp_01_4_01_4.html">cv::DataType&lt; Size_&lt; _Tp &gt; &gt;</a></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcv_1_1DataType_3_01std_1_1complex_3_01__Tp_01_4_01_4.html">cv::DataType&lt; std::complex&lt; _Tp &gt; &gt;</a></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcv_1_1DataType_3_01uchar_01_4.html">cv::DataType&lt; uchar &gt;</a></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcv_1_1DataType_3_01ushort_01_4.html">cv::DataType&lt; ushort &gt;</a></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcv_1_1DataType_3_01Vec_3_01__Tp_00_01cn_01_4_01_4.html">cv::DataType&lt; Vec&lt; _Tp, cn &gt; &gt;</a></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcv_1_1Exception.html">cv::Exception</a></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcv_1_1FileNode.html">cv::FileNode</a></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcv_1_1FileNodeIterator.html">cv::FileNodeIterator</a></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcv_1_1FileStorage.html">cv::FileStorage</a></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structcv_1_1SparseMat_1_1Hdr.html">cv::SparseMat::Hdr</a></td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">the sparse matrix header  <a href="structcv_1_1SparseMat_1_1Hdr.html#details">More...</a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcv_1_1KDTree.html">cv::KDTree</a></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcv_1_1LineIterator.html">cv::LineIterator</a></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcv_1_1Mat.html">cv::Mat</a></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcv_1_1Mat__.html">cv::Mat_&lt; _Tp &gt;</a></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcv_1_1MatAllocator.html">cv::MatAllocator</a></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcv_1_1MatCommaInitializer__.html">cv::MatCommaInitializer_&lt; _Tp &gt;</a></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcv_1_1MatConstIterator.html">cv::MatConstIterator</a></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcv_1_1MatConstIterator__.html">cv::MatConstIterator_&lt; _Tp &gt;</a></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcv_1_1MatIterator__.html">cv::MatIterator_&lt; _Tp &gt;</a></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcv_1_1Matx.html">cv::Matx&lt; _Tp, m, n &gt;</a></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structcv_1_1Matx__AddOp.html">cv::Matx_AddOp</a></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structcv_1_1Matx__MatMulOp.html">cv::Matx_MatMulOp</a></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structcv_1_1Matx__MulOp.html">cv::Matx_MulOp</a></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structcv_1_1Matx__ScaleOp.html">cv::Matx_ScaleOp</a></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structcv_1_1Matx__SubOp.html">cv::Matx_SubOp</a></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structcv_1_1Matx__TOp.html">cv::Matx_TOp</a></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcv_1_1MatxCommaInitializer.html">cv::MatxCommaInitializer&lt; _Tp, m, n &gt;</a></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structcv_1_1Mat_1_1MSize.html">cv::Mat::MSize</a></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structcv_1_1Mat_1_1MStep.html">cv::Mat::MStep</a></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcv_1_1NAryMatIterator.html">cv::NAryMatIterator</a></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structcv_1_1KDTree_1_1Node.html">cv::KDTree::Node</a></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structcv_1_1SparseMat_1_1Node.html">cv::SparseMat::Node</a></td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">sparse matrix node - element of a hash table  <a href="structcv_1_1SparseMat_1_1Node.html#details">More...</a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcv_1_1PCA.html">cv::PCA</a></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcv_1_1Point3__.html">cv::Point3_&lt; _Tp &gt;</a></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcv_1_1Point__.html">cv::Point_&lt; _Tp &gt;</a></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcv_1_1Ptr.html">cv::Ptr&lt; _Tp &gt;</a></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcv_1_1Range.html">cv::Range</a></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcv_1_1Allocator_1_1rebind.html">cv::Allocator&lt; _Tp &gt;::rebind&lt; U &gt;</a></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcv_1_1Rect__.html">cv::Rect_&lt; _Tp &gt;</a></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcv_1_1RNG.html">cv::RNG</a></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcv_1_1RotatedRect.html">cv::RotatedRect</a></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcv_1_1Scalar__.html">cv::Scalar_&lt; _Tp &gt;</a></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcv_1_1Seq.html">cv::Seq&lt; _Tp &gt;</a></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcv_1_1SeqIterator.html">cv::SeqIterator&lt; _Tp &gt;</a></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcv_1_1Size__.html">cv::Size_&lt; _Tp &gt;</a></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcv_1_1SparseMat.html">cv::SparseMat</a></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcv_1_1SparseMat__.html">cv::SparseMat_&lt; _Tp &gt;</a></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcv_1_1SparseMatConstIterator.html">cv::SparseMatConstIterator</a></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcv_1_1SparseMatConstIterator__.html">cv::SparseMatConstIterator_&lt; _Tp &gt;</a></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcv_1_1SparseMatIterator.html">cv::SparseMatIterator</a></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcv_1_1SparseMatIterator__.html">cv::SparseMatIterator_&lt; _Tp &gt;</a></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcv_1_1SVD.html">cv::SVD</a></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcv_1_1TermCriteria.html">cv::TermCriteria</a></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcv_1_1Vec.html">cv::Vec&lt; _Tp, cn &gt;</a></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcv_1_1VecCommaInitializer.html">cv::VecCommaInitializer&lt; _Tp, m &gt;</a></td></tr>
<tr><td colspan="2"><h2><a name="namespaces"></a>
Namespaces</h2></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">namespace &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacecv.html">cv</a></td></tr>
<tr><td colspan="2"><h2><a name="define-members"></a>
Defines</h2></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="core_8hpp~.html#aebbd3a08c72b75549ea54c4b8fa6fc86">__OPENCV_CORE_HPP__</a></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="core_8hpp~.html#af62bcd90f70e275191ab95136d85906b">CV_Assert</a>(expr)&#160;&#160;&#160;if((expr)) ; else cv::error( <a class="el" href="classcv_1_1Exception.html">cv::Exception</a>(CV_StsAssert, #expr, &quot;&quot;, __FILE__, __LINE__) )</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="core_8hpp~.html#afbcb487cba05bd288dbe18c433de4f6f">CV_DbgAssert</a>(expr)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="core_8hpp~.html#a5b48c333c777666e076bd7052799f891">CV_Error</a>(code, msg)&#160;&#160;&#160;cv::error( <a class="el" href="classcv_1_1Exception.html">cv::Exception</a>(code, msg, &quot;&quot;, __FILE__, __LINE__) )</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="core_8hpp~.html#a1c0cd6e5bd9a5f915c6cab9c0632f969">CV_Error_</a>(code, args)&#160;&#160;&#160;cv::error( <a class="el" href="classcv_1_1Exception.html">cv::Exception</a>(code, cv::format args, &quot;&quot;, __FILE__, __LINE__) )</td></tr>
<tr><td colspan="2"><h2><a name="enum-members"></a>
Enumerations</h2></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">enum &#160;</td><td class="memItemRight" valign="bottom">{ <br/>
&#160;&#160;<a class="el" href="namespacecv.html#abc27c7c11fa8dfddb0cfc78c3533362da716178fb8ebf6fb8730aceaddb5df5c7">cv::DECOMP_LU</a> = 0, 
<a class="el" href="namespacecv.html#abc27c7c11fa8dfddb0cfc78c3533362dad9620bfd7baaabc35c58bc20f65609a5">cv::DECOMP_SVD</a> = 1, 
<a class="el" href="namespacecv.html#abc27c7c11fa8dfddb0cfc78c3533362da01a7fe0cd093996922950092e878091f">cv::DECOMP_EIG</a> = 2, 
<a class="el" href="namespacecv.html#abc27c7c11fa8dfddb0cfc78c3533362dac56da3435a7d899ee1b6d440e67b137e">cv::DECOMP_CHOLESKY</a> = 3, 
<br/>
&#160;&#160;<a class="el" href="namespacecv.html#abc27c7c11fa8dfddb0cfc78c3533362da7578909c693c5e4e881576b7b3e05861">cv::DECOMP_QR</a> = 4, 
<a class="el" href="namespacecv.html#abc27c7c11fa8dfddb0cfc78c3533362da6553616eb5c409fe7c4ddeee081743f9">cv::DECOMP_NORMAL</a> = 16
<br/>
 }</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">enum &#160;</td><td class="memItemRight" valign="bottom">{ <br/>
&#160;&#160;<a class="el" href="namespacecv.html#a14f93c5f56c2401d3630b01316fcb612a0c4c92909d682058140af0cb19cfa29d">cv::NORM_INF</a> = 1, 
<a class="el" href="namespacecv.html#a14f93c5f56c2401d3630b01316fcb612a0f5618d594c5573c79447393362f1bff">cv::NORM_L1</a> = 2, 
<a class="el" href="namespacecv.html#a14f93c5f56c2401d3630b01316fcb612a5b9fd9689be4e2cc80c59265cb585e51">cv::NORM_L2</a> = 4, 
<a class="el" href="namespacecv.html#a14f93c5f56c2401d3630b01316fcb612a1dd7c5ffd11fb83c552cfc1d07a66f7d">cv::NORM_TYPE_MASK</a> = 7, 
<br/>
&#160;&#160;<a class="el" href="namespacecv.html#a14f93c5f56c2401d3630b01316fcb612ab9cb974634e51eb1bb93f3bdc86cb9e1">cv::NORM_RELATIVE</a> = 8, 
<a class="el" href="namespacecv.html#a14f93c5f56c2401d3630b01316fcb612a2ff2c0b35834ef8e83381206561f5cb9">cv::NORM_MINMAX</a> = 32
<br/>
 }</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">enum &#160;</td><td class="memItemRight" valign="bottom">{ <br/>
&#160;&#160;<a class="el" href="namespacecv.html#aae4cfba5e6d13ba37406745998d5eae4a8809b279138543558d40499fcc190766">cv::CMP_EQ</a> = 0, 
<a class="el" href="namespacecv.html#aae4cfba5e6d13ba37406745998d5eae4ac268d7c7328d450aa2147c110f39d0a6">cv::CMP_GT</a> = 1, 
<a class="el" href="namespacecv.html#aae4cfba5e6d13ba37406745998d5eae4ab7ba4bfc765a97c7466f01676d8ff684">cv::CMP_GE</a> = 2, 
<a class="el" href="namespacecv.html#aae4cfba5e6d13ba37406745998d5eae4ab5324490a5a5627eff95dcab952f6521">cv::CMP_LT</a> = 3, 
<br/>
&#160;&#160;<a class="el" href="namespacecv.html#aae4cfba5e6d13ba37406745998d5eae4a324285ac3d9889272e609d1b5edd23a6">cv::CMP_LE</a> = 4, 
<a class="el" href="namespacecv.html#aae4cfba5e6d13ba37406745998d5eae4a9bfb3fd93e7507a3cfbd28bc091bc2c4">cv::CMP_NE</a> = 5
<br/>
 }</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">enum &#160;</td><td class="memItemRight" valign="bottom">{ <a class="el" href="namespacecv.html#a7a77c156374ee0ea440bd3ed0d387240a0f991af7fd90b8586a53d3ba96b71340">cv::GEMM_1_T</a> = 1, 
<a class="el" href="namespacecv.html#a7a77c156374ee0ea440bd3ed0d387240a303d11dea6b495e42be1247bee816614">cv::GEMM_2_T</a> = 2, 
<a class="el" href="namespacecv.html#a7a77c156374ee0ea440bd3ed0d387240a2676d396e151736fb6e35f771ca1cf8e">cv::GEMM_3_T</a> = 4
 }</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">enum &#160;</td><td class="memItemRight" valign="bottom">{ <br/>
&#160;&#160;<a class="el" href="namespacecv.html#adef9f79b2930ffa9273d64d0b0eaeba2a74c625cb38e7d4dcd85de61b61e98228">cv::DFT_INVERSE</a> = 1, 
<a class="el" href="namespacecv.html#adef9f79b2930ffa9273d64d0b0eaeba2ac0981f506ac69f189316b3ee9cb566c1">cv::DFT_SCALE</a> = 2, 
<a class="el" href="namespacecv.html#adef9f79b2930ffa9273d64d0b0eaeba2a9160082f0ac754a3a9eeba3ccbb4a501">cv::DFT_ROWS</a> = 4, 
<a class="el" href="namespacecv.html#adef9f79b2930ffa9273d64d0b0eaeba2a19beb828de947abf7f3f728a3d5af990">cv::DFT_COMPLEX_OUTPUT</a> = 16, 
<br/>
&#160;&#160;<a class="el" href="namespacecv.html#adef9f79b2930ffa9273d64d0b0eaeba2a07462ae167b94721b8c0449e842f7f64">cv::DFT_REAL_OUTPUT</a> = 32, 
<a class="el" href="namespacecv.html#adef9f79b2930ffa9273d64d0b0eaeba2af682795cb2e4d849edee3df5d3dee7d5">cv::DCT_INVERSE</a> =  DFT_INVERSE, 
<a class="el" href="namespacecv.html#adef9f79b2930ffa9273d64d0b0eaeba2a542120cffcb4a8d82032a0bd96320b24">cv::DCT_ROWS</a> = DFT_ROWS
<br/>
 }</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">enum &#160;</td><td class="memItemRight" valign="bottom">{ <a class="el" href="namespacecv.html#ab3877441e61bee91e069c676c14ba1d4a377e50027ab1f05d2d2e03133c19d2ea">cv::MAGIC_MASK</a> = 0xFFFF0000, 
<a class="el" href="namespacecv.html#ab3877441e61bee91e069c676c14ba1d4af19cf325e071897085b92e838f6fea5b">cv::TYPE_MASK</a> = 0x00000FFF, 
<a class="el" href="namespacecv.html#ab3877441e61bee91e069c676c14ba1d4a95b858709ac07d35ad95f1c045109f1d">cv::DEPTH_MASK</a> = 7
 }</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">enum &#160;</td><td class="memItemRight" valign="bottom">{ <a class="el" href="namespacecv.html#af8bdb3390c387e439b50922bd20163e9a3eed85413f018f76f934abead4107d40">cv::KMEANS_RANDOM_CENTERS</a> = 0, 
<a class="el" href="namespacecv.html#af8bdb3390c387e439b50922bd20163e9accdca30f8572e721ff4f2987af4fb239">cv::KMEANS_PP_CENTERS</a> = 2, 
<a class="el" href="namespacecv.html#af8bdb3390c387e439b50922bd20163e9a0e73405c5d1d57087b68d3abbadfe80c">cv::KMEANS_USE_INITIAL_LABELS</a> = 1
 }</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">enum &#160;</td><td class="memItemRight" valign="bottom">{ <br/>
&#160;&#160;<a class="el" href="namespacecv.html#aaf22a2d74753d774425b9d7ac00f856bab48036e34c7345081828fc40be41f706">cv::FONT_HERSHEY_SIMPLEX</a> =  0, 
<a class="el" href="namespacecv.html#aaf22a2d74753d774425b9d7ac00f856ba28f4fe57ba39223de34d640e4fdec6af">cv::FONT_HERSHEY_PLAIN</a> =  1, 
<a class="el" href="namespacecv.html#aaf22a2d74753d774425b9d7ac00f856ba50ce924732935f857897d01214de8a6a">cv::FONT_HERSHEY_DUPLEX</a> =  2, 
<a class="el" href="namespacecv.html#aaf22a2d74753d774425b9d7ac00f856ba4c0f5d1ede46cb9176e18f15eb480ed8">cv::FONT_HERSHEY_COMPLEX</a> =  3, 
<br/>
&#160;&#160;<a class="el" href="namespacecv.html#aaf22a2d74753d774425b9d7ac00f856ba8659e305bf287a8a45178675715b2e81">cv::FONT_HERSHEY_TRIPLEX</a> =  4, 
<a class="el" href="namespacecv.html#aaf22a2d74753d774425b9d7ac00f856baede005b5a264b47698d753c82b160c7c">cv::FONT_HERSHEY_COMPLEX_SMALL</a> =  5, 
<a class="el" href="namespacecv.html#aaf22a2d74753d774425b9d7ac00f856bad15c127df42cda7febc4310982e736d5">cv::FONT_HERSHEY_SCRIPT_SIMPLEX</a> =  6, 
<a class="el" href="namespacecv.html#aaf22a2d74753d774425b9d7ac00f856ba2027312e78b96cf4484b971b9efae129">cv::FONT_HERSHEY_SCRIPT_COMPLEX</a> =  7, 
<br/>
&#160;&#160;<a class="el" href="namespacecv.html#aaf22a2d74753d774425b9d7ac00f856babc44ccc1888bb6b495b7353fc1ad444a">cv::FONT_ITALIC</a> =  16
<br/>
 }</td></tr>
<tr><td colspan="2"><h2><a name="func-members"></a>
Functions</h2></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">CV_EXPORTS_W void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacecv.html#abedc1d9dd1836c45f34c9bd44040581b">cv::absdiff</a> (const Mat &amp;src1, const Mat &amp;src2, CV_OUT Mat &amp;dst)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">computes element-wise absolute difference of two arrays (dst = abs(src1 - src2))  <a href="#abedc1d9dd1836c45f34c9bd44040581b"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">CV_EXPORTS_W void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacecv.html#a68048eb7a049c3f6ee603759bbde6abb">cv::absdiff</a> (const Mat &amp;src1, const Scalar &amp;src2, CV_OUT Mat &amp;dst)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">computes element-wise absolute difference of array and scalar (dst = abs(src1 - src2))  <a href="#a68048eb7a049c3f6ee603759bbde6abb"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">CV_EXPORTS_W void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacecv.html#a5fe1c189a97c40a07be2b31a7bc90e9e">cv::add</a> (const Mat &amp;src1, const Mat &amp;src2, CV_OUT Mat &amp;dst, const Mat &amp;mask CV_WRAP_DEFAULT(Mat()))</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">adds one matrix to another (dst = src1 + src2)  <a href="#a5fe1c189a97c40a07be2b31a7bc90e9e"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">CV_EXPORTS_W void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacecv.html#ab6bb31768c1fa5b8ec1e0e597f11a472">cv::add</a> (const Mat &amp;src1, const Scalar &amp;src2, CV_OUT Mat &amp;dst, const Mat &amp;mask=Mat())</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">adds scalar to a matrix (dst = src1 + src2)  <a href="#ab6bb31768c1fa5b8ec1e0e597f11a472"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacecv.html#ad2f5a5a6187760b210907e57ef20515f">cv::add</a> (const Mat &amp;src1, const Mat &amp;src2, CV_OUT Mat &amp;dst)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">adds one matrix to another (dst = src1 + src2)  <a href="#ad2f5a5a6187760b210907e57ef20515f"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">CV_EXPORTS_W void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacecv.html#a7a787331620fff73cfc26d1dc4ad5f31">cv::addWeighted</a> (const Mat &amp;src1, double alpha, const Mat &amp;src2, double beta, double gamma, CV_OUT Mat &amp;dst)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">computes weighted sum of two arrays (dst = alpha*src1 + beta*src2 + gamma)  <a href="#a7a787331620fff73cfc26d1dc4ad5f31"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">CV_EXPORTS_W void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacecv.html#a32569aad640af443eee05eb775c37923">cv::bitwise_and</a> (const Mat &amp;src1, const Mat &amp;src2, CV_OUT Mat &amp;dst, const Mat &amp;mask=Mat())</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">computes bitwise conjunction of the two arrays (dst = src1 &amp; src2)  <a href="#a32569aad640af443eee05eb775c37923"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">CV_EXPORTS_W void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacecv.html#aa8eae72a28be324579e18c703abf76c7">cv::bitwise_and</a> (const Mat &amp;src1, const Scalar &amp;src2, CV_OUT Mat &amp;dst, const Mat &amp;mask=Mat())</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">computes bitwise conjunction of an array and scalar (dst = src1 &amp; src2)  <a href="#aa8eae72a28be324579e18c703abf76c7"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">CV_EXPORTS_W void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacecv.html#aa0ac5c570119b0fd7ffbe4b5992782d1">cv::bitwise_not</a> (const Mat &amp;src, CV_OUT Mat &amp;dst)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">inverts each bit of array (dst = ~src)  <a href="#aa0ac5c570119b0fd7ffbe4b5992782d1"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">CV_EXPORTS_W void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacecv.html#ae3fbf416b6586350797ea892062c2b24">cv::bitwise_or</a> (const Mat &amp;src1, const Mat &amp;src2, CV_OUT Mat &amp;dst, const Mat &amp;mask=Mat())</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">computes bitwise disjunction of the two arrays (dst = src1 | src2)  <a href="#ae3fbf416b6586350797ea892062c2b24"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">CV_EXPORTS_W void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacecv.html#aeb48591a499821fe874612f8cd47a830">cv::bitwise_or</a> (const Mat &amp;src1, const Scalar &amp;src2, CV_OUT Mat &amp;dst, const Mat &amp;mask=Mat())</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">computes bitwise disjunction of an array and scalar (dst = src1 | src2)  <a href="#aeb48591a499821fe874612f8cd47a830"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">CV_EXPORTS_W void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacecv.html#a4ca8df52221c629495f098968b670fee">cv::bitwise_xor</a> (const Mat &amp;src1, const Mat &amp;src2, CV_OUT Mat &amp;dst, const Mat &amp;mask=Mat())</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">computes bitwise exclusive-or of the two arrays (dst = src1 ^ src2)  <a href="#a4ca8df52221c629495f098968b670fee"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">CV_EXPORTS_W void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacecv.html#a8e4c5e2cf41c7e25ef506ced56cf38b0">cv::bitwise_xor</a> (const Mat &amp;src1, const Scalar &amp;src2, CV_OUT Mat &amp;dst, const Mat &amp;mask=Mat())</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">computes bitwise exclusive-or of an array and scalar (dst = src1 ^ src2)  <a href="#a8e4c5e2cf41c7e25ef506ced56cf38b0"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacecv.html#ae6ffa9354633f984246945d52823165d">cv::calcCovarMatrix</a> (const Mat *samples, int nsamples, Mat &amp;covar, Mat &amp;mean, int <a class="el" href="highgui__c_8h.html#a537e9e30547f68fff6358cc410095bb9">flags</a>, int ctype=CV_64F)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">computes covariation matrix of a set of samples  <a href="#ae6ffa9354633f984246945d52823165d"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">CV_EXPORTS_W void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacecv.html#a796e08bfa731d4e7347e24605efab858">cv::calcCovarMatrix</a> (const Mat &amp;samples, CV_OUT Mat &amp;covar, CV_OUT Mat &amp;mean, int <a class="el" href="highgui__c_8h.html#a537e9e30547f68fff6358cc410095bb9">flags</a>, int ctype=CV_64F)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">computes covariation matrix of a set of samples  <a href="#a796e08bfa731d4e7347e24605efab858"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">CV_EXPORTS_W void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacecv.html#a1132811eea81e850a8dbe4492495098e">cv::cartToPolar</a> (const Mat &amp;<a class="el" href="highgui__c_8h.html#ad77deca22f617d3f0e0eb786445689fc">x</a>, const Mat &amp;<a class="el" href="highgui__c_8h.html#a9298c7ad619074f5285b32c6b72bfdea">y</a>, CV_OUT Mat &amp;magnitude, CV_OUT Mat &amp;angle, bool angleInDegrees=false)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">converts Cartesian coordinates to polar  <a href="#a1132811eea81e850a8dbe4492495098e"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">CV_EXPORTS_W bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacecv.html#a66c4ca8120f8fe97b87e358d626b06b7">cv::checkHardwareSupport</a> (int feature)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">CV_EXPORTS_W bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacecv.html#a78a7780201d489585f639b76ad0fe2ff">cv::checkRange</a> (const Mat &amp;a, bool quiet=true, CV_OUT Point *pt=0, double minVal=-DBL_MAX, double maxVal=DBL_MAX)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">checks that each matrix element is within the specified range.  <a href="#a78a7780201d489585f639b76ad0fe2ff"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">CV_EXPORTS_W void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacecv.html#a3ace31b951d2e2b6ca566c0515d1b609">cv::circle</a> (Mat &amp;img, Point center, int radius, const Scalar &amp;color, int thickness=1, int lineType=8, int shift=0)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">draws the circle outline or a solid circle in the image  <a href="#a3ace31b951d2e2b6ca566c0515d1b609"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacecv.html#aa83bdc0f5ed65394990dc9c76484a8be">cv::clipLine</a> (Size imgSize, CV_IN_OUT Point &amp;pt1, CV_IN_OUT Point &amp;pt2)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">clips the line segment by the rectangle Rect(0, 0, imgSize.width, imgSize.height)  <a href="#aa83bdc0f5ed65394990dc9c76484a8be"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">CV_EXPORTS_W bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacecv.html#a54fc21eeb2b834184d04b37dbce79363">cv::clipLine</a> (Rect imgRect, CV_IN_OUT Point &amp;pt1, CV_IN_OUT Point &amp;pt2)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">clips the line segment by the rectangle imgRect  <a href="#a54fc21eeb2b834184d04b37dbce79363"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">CV_EXPORTS_W void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacecv.html#a15eac4562eb011a4b252c60e18a46768">cv::compare</a> (const Mat &amp;src1, double s, CV_OUT Mat &amp;dst, int cmpop)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">compares elements of array with scalar (dst = src1 &lt;cmpop&gt; src2)  <a href="#a15eac4562eb011a4b252c60e18a46768"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">CV_EXPORTS_W void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacecv.html#a7b21c8c22350623a0895ccd506b954d7">cv::compare</a> (const Mat &amp;src1, const Mat &amp;src2, CV_OUT Mat &amp;dst, int cmpop)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">compares elements of two arrays (dst = src1 &lt;cmpop&gt; src2)  <a href="#a7b21c8c22350623a0895ccd506b954d7"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">CV_EXPORTS_W void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacecv.html#ae5097dd9fc369f49f4025a99fd48e086">cv::completeSymm</a> (Mat &amp;mtx, bool lowerToUpper=false)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">extends the symmetrical matrix from the lower half or from the upper half  <a href="#ae5097dd9fc369f49f4025a99fd48e086"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">CV_EXPORTS_W void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacecv.html#a23c74f01bd87b50b4d26c1238c816f5e">cv::convertScaleAbs</a> (const Mat &amp;src, CV_OUT Mat &amp;dst, double alpha=1, double beta=0)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">scales array elements, computes absolute values and converts the results to 8-bit unsigned integers: dst(i)=saturate_cast&lt;uchar&gt;abs(src(i)*alpha+beta)  <a href="#a23c74f01bd87b50b4d26c1238c816f5e"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">CV_EXPORTS_W int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacecv.html#a95fdba31b9e9aa20b3dcb3fabc453b2e">cv::countNonZero</a> (const Mat &amp;src)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">computes the number of nonzero array elements  <a href="#a95fdba31b9e9aa20b3dcb3fabc453b2e"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">CV_EXPORTS_W float&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacecv.html#a4d064b83b4a7d49cf55176073dcd562c">cv::cubeRoot</a> (float val)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">computes cube root of the argument  <a href="#a4d064b83b4a7d49cf55176073dcd562c"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">Mat&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacecv.html#a5a7f94e0cd779061f3835f559d72e77c">cv::cvarrToMat</a> (const <a class="el" href="core_2include_2opencv2_2core_2types__c_8h.html#ac5046bc0456e9295d80b37774384798c">CvArr</a> *arr, bool copyData=false, bool allowND=true, int coiMode=0)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">converts array (<a class="el" href="structCvMat.html">CvMat</a> or IplImage) to <a class="el" href="classcv_1_1Mat.html">cv::Mat</a>  <a href="#a5a7f94e0cd779061f3835f559d72e77c"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">CV_EXPORTS_W void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacecv.html#ab3cc0feeee99c14703ecec7a8372bc75">cv::dct</a> (const Mat &amp;src, CV_OUT Mat &amp;dst, int <a class="el" href="highgui__c_8h.html#a537e9e30547f68fff6358cc410095bb9">flags</a>=0)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">performs forward or inverse 1D or 2D Discrete Cosine Transformation  <a href="#ab3cc0feeee99c14703ecec7a8372bc75"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">CV_EXPORTS_W double&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacecv.html#acd74e4d69874efdc2365382d1fa80b23">cv::determinant</a> (const Mat &amp;mtx)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">computes determinant of a square matrix  <a href="#acd74e4d69874efdc2365382d1fa80b23"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">CV_EXPORTS_W void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacecv.html#a26add08bde3a4f6a2a93ccdaac2b0dbc">cv::dft</a> (const Mat &amp;src, CV_OUT Mat &amp;dst, int <a class="el" href="highgui__c_8h.html#a537e9e30547f68fff6358cc410095bb9">flags</a>=0, int nonzeroRows=0)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">performs forward or inverse 1D or 2D Discrete Fourier Transformation  <a href="#a26add08bde3a4f6a2a93ccdaac2b0dbc"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">CV_EXPORTS_W void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacecv.html#ae97060dcfdb21f567684214ca90101e6">cv::divide</a> (const Mat &amp;src1, const Mat &amp;src2, CV_OUT Mat &amp;dst, double scale=1)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">computes element-wise weighted quotient of the two arrays (dst = scale*src1/src2)  <a href="#ae97060dcfdb21f567684214ca90101e6"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">CV_EXPORTS_W void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacecv.html#a5c78f6d981c8dfda23a7e941c008eab5">cv::divide</a> (double scale, const Mat &amp;src2, CV_OUT Mat &amp;dst)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">computes element-wise weighted reciprocal of an array (dst = scale/src2)  <a href="#a5c78f6d981c8dfda23a7e941c008eab5"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacecv.html#a809a21228c5b5c2d3eb9d40e56f14fb3">cv::eigen</a> (const Mat &amp;src, CV_OUT Mat &amp;eigenvalues, int lowindex=-1, int highindex=-1)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">finds eigenvalues of a symmetric matrix  <a href="#a809a21228c5b5c2d3eb9d40e56f14fb3"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacecv.html#aeda10a116f5c5dae7e0114adf662717d">cv::eigen</a> (const Mat &amp;src, CV_OUT Mat &amp;eigenvalues, CV_OUT Mat &amp;eigenvectors, int lowindex=-1, int highindex=-1)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">finds eigenvalues and eigenvectors of a symmetric matrix  <a href="#aeda10a116f5c5dae7e0114adf662717d"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">CV_EXPORTS_W void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacecv.html#ad8e5846cb55917d0c6d8669d67e00a21">cv::ellipse</a> (Mat &amp;img, Point center, Size axes, double angle, double startAngle, double endAngle, const Scalar &amp;color, int thickness=1, int lineType=8, int shift=0)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">draws an elliptic arc, ellipse sector or a rotated ellipse in the image  <a href="#ad8e5846cb55917d0c6d8669d67e00a21"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">CV_EXPORTS_W void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacecv.html#adb3874f09bd7b3b54fe1cb892d78f9a0">cv::ellipse</a> (Mat &amp;img, const RotatedRect &amp;box, const Scalar &amp;color, int thickness=1, int lineType=8)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">draws a rotated ellipse in the image  <a href="#adb3874f09bd7b3b54fe1cb892d78f9a0"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">CV_EXPORTS_W void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacecv.html#aa7e62ecfc1b8e535ebdb2080560c2819">cv::ellipse2Poly</a> (Point center, Size axes, int angle, int arcStart, int arcEnd, int delta, CV_OUT vector&lt; Point &gt; &amp;pts)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">converts elliptic arc to a polygonal curve  <a href="#aa7e62ecfc1b8e535ebdb2080560c2819"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacecv.html#a4910d7f86336cd4eff9dd05575667e41">cv::error</a> (const Exception &amp;exc)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Signals an error and raises the exception.  <a href="#a4910d7f86336cd4eff9dd05575667e41"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">CV_EXPORTS_W void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacecv.html#ab92ce84936135d98dae706fc1ca7c66f">cv::exp</a> (const Mat &amp;src, CV_OUT Mat &amp;dst)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">computes exponent of each matrix element (dst = e**src)  <a href="#ab92ce84936135d98dae706fc1ca7c66f"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacecv.html#ad2a4409834f6bca902a25667bafc5aa9">cv::extractImageCOI</a> (const <a class="el" href="core_2include_2opencv2_2core_2types__c_8h.html#ac5046bc0456e9295d80b37774384798c">CvArr</a> *arr, CV_OUT Mat &amp;coiimg, int coi=-1)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">extracts Channel of Interest from <a class="el" href="structCvMat.html">CvMat</a> or IplImage and makes <a class="el" href="classcv_1_1Mat.html">cv::Mat</a> out of it.  <a href="#ad2a4409834f6bca902a25667bafc5aa9"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">CV_EXPORTS_W float&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacecv.html#ab992f84022886e0b3df4ccdd5760f0dc">cv::fastAtan2</a> (float <a class="el" href="highgui__c_8h.html#a9298c7ad619074f5285b32c6b72bfdea">y</a>, float <a class="el" href="highgui__c_8h.html#ad77deca22f617d3f0e0eb786445689fc">x</a>)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">computes the angle in degrees (0..360) of the vector (x,y)  <a href="#ab992f84022886e0b3df4ccdd5760f0dc"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacecv.html#a4b0d54a6957761ba64880fa51c4b8a6b">cv::fastFree</a> (void *ptr)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacecv.html#ac0fbe1104c56f83d292d1b6ba79c4e4e">cv::fastMalloc</a> (size_t bufSize)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacecv.html#a936205b9b3d8c69f27be8111ddd056b6">cv::fillConvexPoly</a> (Mat &amp;img, const Point *pts, int npts, const Scalar &amp;color, int lineType=8, int shift=0)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">draws a filled convex polygon in the image  <a href="#a936205b9b3d8c69f27be8111ddd056b6"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacecv.html#a32c3853ef3688ed81ec0e9c1e9fc72ef">cv::fillPoly</a> (Mat &amp;img, const Point **pts, const int *npts, int ncontours, const Scalar &amp;color, int lineType=8, int shift=0, Point offset=Point())</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">fills an area bounded by one or more polygons  <a href="#a32c3853ef3688ed81ec0e9c1e9fc72ef"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">CV_EXPORTS_W void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacecv.html#a318c6c854831ad541ac9c37c2f9d1fce">cv::flip</a> (const Mat &amp;src, CV_OUT Mat &amp;dst, int flipCode)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">reverses the order of the rows, columns or both in a matrix  <a href="#a318c6c854831ad541ac9c37c2f9d1fce"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">string&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacecv.html#a60a078dac5999f57563caf7c6600460f">cv::format</a> (const char *fmt,...)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">string&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacecv.html#a3d0f85d77fa415d613cc4190ff791cba">cv::fromUtf16</a> (const WString &amp;str)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">CV_EXPORTS_W void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacecv.html#a665e5d80b292f32e8f206a577fa25098">cv::gemm</a> (const Mat &amp;src1, const Mat &amp;src2, double alpha, const Mat &amp;src3, double gamma, CV_OUT Mat &amp;dst, int <a class="el" href="highgui__c_8h.html#a537e9e30547f68fff6358cc410095bb9">flags</a>=0)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">implements generalized matrix product algorithm GEMM from BLAS  <a href="#a665e5d80b292f32e8f206a577fa25098"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">ConvertData&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacecv.html#a0adcb4108409b36a0e8e44aa2ebaa349">cv::getConvertElem</a> (int fromType, int toType)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">returns the function for converting pixels from one data type to another  <a href="#a0adcb4108409b36a0e8e44aa2ebaa349"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">ConvertScaleData&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacecv.html#af453d59159d541d9942cf0c8ca84047b">cv::getConvertScaleElem</a> (int fromType, int toType)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">returns the function for converting pixels from one data type to another with the optional scaling  <a href="#af453d59159d541d9942cf0c8ca84047b"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="core_2include_2opencv2_2core_2types__c_8h.html#a7cde0074dfd288f2d70c0e035dacb28a">int64</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacecv.html#af3070efdcfef6f1e7ac28d2b6a29a7c0">cv::getCPUTickCount</a> ()</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacecv.html#a2db334ec41d98da3129ef4a2342fc4d4">cv::getNumThreads</a> ()</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">CV_EXPORTS_W int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacecv.html#a65771bed36f50b52998c2a9131db19da">cv::getOptimalDFTSize</a> (int vecsize)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">computes the minimal vector size vecsize1 &gt;= vecsize so that the <a class="el" href="namespacecv.html#a26add08bde3a4f6a2a93ccdaac2b0dbc" title="performs forward or inverse 1D or 2D Discrete Fourier Transformation">dft()</a> of the vector of length vecsize1 can be computed efficiently  <a href="#a65771bed36f50b52998c2a9131db19da"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">CV_EXPORTS_W Size&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacecv.html#a482cdab6db1351cfad14868810b14660">cv::getTextSize</a> (const string &amp;text, int fontFace, double fontScale, int thickness, CV_OUT int *baseLine)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">returns bounding box of the text string  <a href="#a482cdab6db1351cfad14868810b14660"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacecv.html#af9cc0cb10097686a9da60f6c587e5774">cv::getThreadNum</a> ()</td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="core_2include_2opencv2_2core_2types__c_8h.html#a7cde0074dfd288f2d70c0e035dacb28a">int64</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacecv.html#ae73f58000611a1af25dd36d496bf4487">cv::getTickCount</a> ()</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the number of ticks.  <a href="#ae73f58000611a1af25dd36d496bf4487"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">CV_EXPORTS_W double&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacecv.html#a6ae2c0b0a8f5837a02f42fb9a41dcb5a">cv::getTickFrequency</a> ()</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacecv.html#ac9c52f15957dc4486c423213c8a53a09">cv::hconcat</a> (const Mat *src, size_t nsrc, Mat &amp;dst)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacecv.html#a08e91cf61ab61a0cbce1825b16eeed01">cv::hconcat</a> (const Mat &amp;src1, const Mat &amp;src2, Mat &amp;dst)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">CV_EXPORTS_W void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacecv.html#ae7f2fbd3b43de25f9ec83bdad4222bcc">cv::hconcat</a> (const vector&lt; Mat &gt; &amp;src, CV_OUT Mat &amp;dst)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">CV_EXPORTS_W void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacecv.html#ab0057e2890c4b0670f7839219a5a761d">cv::idct</a> (const Mat &amp;src, CV_OUT Mat &amp;dst, int <a class="el" href="highgui__c_8h.html#a537e9e30547f68fff6358cc410095bb9">flags</a>=0)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">performs inverse 1D or 2D Discrete Cosine Transformation  <a href="#ab0057e2890c4b0670f7839219a5a761d"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">CV_EXPORTS_W void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacecv.html#a121a5388c9c9467b9e1a12aa57260c23">cv::idft</a> (const Mat &amp;src, CV_OUT Mat &amp;dst, int <a class="el" href="highgui__c_8h.html#a537e9e30547f68fff6358cc410095bb9">flags</a>=0, int nonzeroRows=0)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">performs inverse 1D or 2D Discrete Fourier Transformation  <a href="#a121a5388c9c9467b9e1a12aa57260c23"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">CV_EXPORTS_W void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacecv.html#a49d94072be85853ec5bfac4abb306e09">cv::inRange</a> (const Mat &amp;src, const Mat &amp;lowerb, const Mat &amp;upperb, CV_OUT Mat &amp;dst)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">set mask elements for those array elements which are within the element-specific bounding box (dst = lowerb &lt;= src &amp;&amp; src &lt; upperb)  <a href="#a49d94072be85853ec5bfac4abb306e09"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">CV_EXPORTS_W void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacecv.html#a3ceaaecdac478bd8d0d960b01eaec498">cv::inRange</a> (const Mat &amp;src, const Scalar &amp;lowerb, const Scalar &amp;upperb, CV_OUT Mat &amp;dst)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">set mask elements for those array elements which are within the fixed bounding box (dst = lowerb &lt;= src &amp;&amp; src &lt; upperb)  <a href="#a3ceaaecdac478bd8d0d960b01eaec498"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacecv.html#a5f34adc93c9256e80098b0bb242e9bf3">cv::insertImageCOI</a> (const Mat &amp;coiimg, <a class="el" href="core_2include_2opencv2_2core_2types__c_8h.html#ac5046bc0456e9295d80b37774384798c">CvArr</a> *arr, int coi=-1)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">inserts single-channel <a class="el" href="classcv_1_1Mat.html">cv::Mat</a> into a multi-channel <a class="el" href="structCvMat.html">CvMat</a> or IplImage  <a href="#a5f34adc93c9256e80098b0bb242e9bf3"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">CV_EXPORTS_W double&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacecv.html#aebfc4553f25681bd7884c787f1a40f6f">cv::invert</a> (const Mat &amp;src, CV_OUT Mat &amp;dst, int <a class="el" href="highgui__c_8h.html#a537e9e30547f68fff6358cc410095bb9">flags</a>=DECOMP_LU)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">computes inverse or pseudo-inverse matrix  <a href="#aebfc4553f25681bd7884c787f1a40f6f"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">CV_EXPORTS_W double&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacecv.html#a4b29fb324066cd02afc7cd5d9d7431eb">cv::kmeans</a> (const Mat &amp;data, int K, CV_OUT Mat &amp;bestLabels, TermCriteria criteria, int attempts, int <a class="el" href="highgui__c_8h.html#a537e9e30547f68fff6358cc410095bb9">flags</a>, CV_OUT Mat *centers=0)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">clusters the input data using k-Means algorithm  <a href="#a4b29fb324066cd02afc7cd5d9d7431eb"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">CV_EXPORTS_W void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacecv.html#a69c32f48fbb2dfeef952a9690184d0c2">cv::line</a> (Mat &amp;img, Point pt1, Point pt2, const Scalar &amp;color, int thickness=1, int lineType=8, int shift=0)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">draws the line segment (pt1, pt2) in the image  <a href="#a69c32f48fbb2dfeef952a9690184d0c2"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">CV_EXPORTS_W void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacecv.html#a756c152c515f5c06a736fadaef56842f">cv::log</a> (const Mat &amp;src, CV_OUT Mat &amp;dst)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">computes natural logarithm of absolute value of each matrix element: dst = log(abs(src))  <a href="#a756c152c515f5c06a736fadaef56842f"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">CV_EXPORTS_W void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacecv.html#a287dd6f8d898dbee5fe6c198e8f72fce">cv::LUT</a> (const Mat &amp;src, const Mat &amp;lut, CV_OUT Mat &amp;dst)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">transforms 8-bit unsigned integers using lookup table: dst(i)=lut(src(i))  <a href="#a287dd6f8d898dbee5fe6c198e8f72fce"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">CV_EXPORTS_W void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacecv.html#a5ceec35af873e4ad7d149219ff32c069">cv::magnitude</a> (const Mat &amp;<a class="el" href="highgui__c_8h.html#ad77deca22f617d3f0e0eb786445689fc">x</a>, const Mat &amp;<a class="el" href="highgui__c_8h.html#a9298c7ad619074f5285b32c6b72bfdea">y</a>, CV_OUT Mat &amp;magnitude)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">computes magnitude (magnitude(i)) of each (x(i), y(i)) vector  <a href="#a5ceec35af873e4ad7d149219ff32c069"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">CV_EXPORTS_W double&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacecv.html#ada5dbf8b39a9d6aff36dee8568c9d634">cv::Mahalanobis</a> (const Mat &amp;v1, const Mat &amp;v2, const Mat &amp;icovar)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">computes Mahalanobis distance between two vectors: sqrt((v1-v2)'*icovar*(v1-v2)), where icovar is the inverse covariation matrix  <a href="#ada5dbf8b39a9d6aff36dee8568c9d634"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">double&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacecv.html#a148276d2fb5f15b8b0d89377df2527a9">cv::Mahalonobis</a> (const Mat &amp;v1, const Mat &amp;v2, const Mat &amp;icovar)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">a synonym for Mahalanobis  <a href="#a148276d2fb5f15b8b0d89377df2527a9"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">CV_EXPORTS_W void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacecv.html#a57416e28468db6ec3f09e4a133a2c224">cv::max</a> (const Mat &amp;src1, const Mat &amp;src2, CV_OUT Mat &amp;dst)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">computes per-element maximum of two arrays (dst = max(src1, src2))  <a href="#a57416e28468db6ec3f09e4a133a2c224"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">CV_EXPORTS_W void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacecv.html#a1c4205ebfaba9c62c38781e6a4890a32">cv::max</a> (const Mat &amp;src1, double src2, CV_OUT Mat &amp;dst)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">computes per-element maximum of array and scalar (dst = max(src1, src2))  <a href="#a1c4205ebfaba9c62c38781e6a4890a32"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">Scalar&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacecv.html#a79846b4aa959b7301f7d446fbc6bfa21">cv::mean</a> (const Mat &amp;src)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">computes mean value of array elements  <a href="#a79846b4aa959b7301f7d446fbc6bfa21"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">CV_EXPORTS_W Scalar&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacecv.html#abd0a824d3de9f9f0bcf232424de2d5ea">cv::mean</a> (const Mat &amp;src, const Mat &amp;mask CV_WRAP_DEFAULT(Mat()))</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">computes mean value of selected array elements  <a href="#abd0a824d3de9f9f0bcf232424de2d5ea"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">CV_EXPORTS_W void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacecv.html#a74c2b508eafe88ca623ca5b4c9e1efcb">cv::meanStdDev</a> (const Mat &amp;src, CV_OUT Scalar &amp;mean, CV_OUT Scalar &amp;stddev, const Mat &amp;mask=Mat())</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">computes mean value and standard deviation of all or selected array elements  <a href="#a74c2b508eafe88ca623ca5b4c9e1efcb"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacecv.html#ab714cb9ebca8896316922b7580b3f4e1">cv::merge</a> (const Mat *mv, size_t count, CV_OUT Mat &amp;dst)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">makes multi-channel array out of several single-channel arrays  <a href="#ab714cb9ebca8896316922b7580b3f4e1"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">CV_EXPORTS_W void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacecv.html#a7f7f3783ad76bddcd26e6aa715e71ac6">cv::merge</a> (const vector&lt; Mat &gt; &amp;mv, Mat &amp;dst)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">makes multi-channel array out of several single-channel arrays  <a href="#a7f7f3783ad76bddcd26e6aa715e71ac6"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">CV_EXPORTS_W void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacecv.html#a0bdeb3ee8259d5df4655f38d41099070">cv::min</a> (const Mat &amp;src1, const Mat &amp;src2, CV_OUT Mat &amp;dst)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">computes per-element minimum of two arrays (dst = min(src1, src2))  <a href="#a0bdeb3ee8259d5df4655f38d41099070"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">CV_EXPORTS_W void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacecv.html#ad374cb6ad2e0768ba20722a9f3ad8f6d">cv::min</a> (const Mat &amp;src1, double src2, CV_OUT Mat &amp;dst)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">computes per-element minimum of array and scalar (dst = min(src1, src2))  <a href="#ad374cb6ad2e0768ba20722a9f3ad8f6d"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacecv.html#a4bd93bfdfa1c360fb4855f3123a62c16">cv::minMaxIdx</a> (const Mat &amp;src, double *minVal, double *maxVal, int *minIdx=0, int *maxIdx=0, const Mat &amp;mask=Mat())</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacecv.html#a8873b86a29c5af51cafdcee82f8150a7">cv::minMaxLoc</a> (const SparseMat &amp;a, double *minVal, double *maxVal, int *minIdx=0, int *maxIdx=0)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">finds global minimum and maximum sparse array elements and returns their values and their locations  <a href="#a8873b86a29c5af51cafdcee82f8150a7"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">CV_EXPORTS_W void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacecv.html#a7afc836422a6e9a0a1d1b046f8bcd34b">cv::minMaxLoc</a> (const Mat &amp;src, CV_OUT double *minVal, CV_OUT double *maxVal=0, CV_OUT Point *minLoc=0, CV_OUT Point *maxLoc=0, const Mat &amp;mask=Mat())</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">finds global minimum and maximum array elements and returns their values and their locations  <a href="#a7afc836422a6e9a0a1d1b046f8bcd34b"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacecv.html#abef5509e7c68226656588ae9feaf084a">cv::mixChannels</a> (const vector&lt; Mat &gt; &amp;src, vector&lt; Mat &gt; &amp;dst, const int *fromTo, int npairs)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacecv.html#a51d768c270a1cdd3497255017c4504be">cv::mixChannels</a> (const Mat *src, size_t nsrcs, Mat *dst, size_t ndsts, const int *fromTo, size_t npairs)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">copies selected channels from the input arrays to the selected channels of the output arrays  <a href="#a51d768c270a1cdd3497255017c4504be"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">CV_EXPORTS_W void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacecv.html#ad9a5aac6adf884c881e67314780d905a">cv::mulSpectrums</a> (const Mat &amp;a, const Mat &amp;b, CV_OUT Mat &amp;c, int <a class="el" href="highgui__c_8h.html#a537e9e30547f68fff6358cc410095bb9">flags</a>, bool conjB=false)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">computes element-wise product of the two Fourier spectrums. The second spectrum can optionally be conjugated before the multiplication  <a href="#ad9a5aac6adf884c881e67314780d905a"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">CV_EXPORTS_W void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacecv.html#ab1dfe620989ac16be13264684246f9f3">cv::multiply</a> (const Mat &amp;src1, const Mat &amp;src2, CV_OUT Mat &amp;dst, double scale=1)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">computes element-wise weighted product of the two arrays (dst = scale*src1*src2)  <a href="#ab1dfe620989ac16be13264684246f9f3"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">CV_EXPORTS_W void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacecv.html#ae72ca555d2363b0fcec895a7f0b25ab5">cv::mulTransposed</a> (const Mat &amp;src, CV_OUT Mat &amp;dst, bool aTa, const Mat &amp;delta=Mat(), double scale=1, int rtype=-1)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">multiplies matrix by its transposition from the left or from the right  <a href="#ae72ca555d2363b0fcec895a7f0b25ab5"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">double&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacecv.html#a7c331fb8dd951707e184ef4e3f21dd33">cv::norm</a> (const SparseMat &amp;src, int normType)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">computes norm of a sparse matrix  <a href="#a7c331fb8dd951707e184ef4e3f21dd33"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">double&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacecv.html#a7dd251dcee9893767838fff3d80554b3">cv::norm</a> (const Mat &amp;src1, int normType=NORM_L2)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">computes norm of array  <a href="#a7dd251dcee9893767838fff3d80554b3"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">double&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacecv.html#ac8182982fa92664bf52470304a70955b">cv::norm</a> (const Mat &amp;src1, const Mat &amp;src2, int normType=NORM_L2)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">computes norm of the difference between two arrays  <a href="#ac8182982fa92664bf52470304a70955b"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">CV_EXPORTS_W double&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacecv.html#a426bb7dc8a3db7ea33de331f29dbcf1d">cv::norm</a> (const Mat &amp;src1, const Mat &amp;src2, int normType, const Mat &amp;mask CV_WRAP_DEFAULT(Mat()))</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">computes norm of selected part of the difference between two arrays  <a href="#a426bb7dc8a3db7ea33de331f29dbcf1d"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">CV_EXPORTS_W double&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacecv.html#a5cec307e1f20cd59d3677bbefc782a50">cv::norm</a> (const Mat &amp;src1, int normType, const Mat &amp;mask CV_WRAP_DEFAULT(Mat()))</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">computes norm of the selected array part  <a href="#a5cec307e1f20cd59d3677bbefc782a50"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacecv.html#a7bcf47a1df78cf575162e0aed44960cb">cv::normalize</a> (const SparseMat &amp;src, SparseMat &amp;dst, double alpha, int normType)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">scales and shifts array elements so that either the specified norm (alpha) or the minimum (alpha) and maximum (beta) array values get the specified values  <a href="#a7bcf47a1df78cf575162e0aed44960cb"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">CV_EXPORTS_W void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacecv.html#a56e4378b170a97ff6e6f3a25b87c8052">cv::normalize</a> (const Mat &amp;src, CV_OUT Mat &amp;dst, double alpha=1, double beta=0, int norm_type=NORM_L2, int rtype=-1, const Mat &amp;mask=Mat())</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">scales and shifts array elements so that either the specified norm (alpha) or the minimum (alpha) and maximum (beta) array values get the specified values  <a href="#a56e4378b170a97ff6e6f3a25b87c8052"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">CV_EXPORTS_W void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacecv.html#a90d469dfd90cdc3904bb8b4179ec896d">cv::perspectiveTransform</a> (const Mat &amp;src, CV_OUT Mat &amp;dst, const Mat &amp;m)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">performs perspective transformation of each element of multi-channel input matrix  <a href="#a90d469dfd90cdc3904bb8b4179ec896d"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">CV_EXPORTS_W void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacecv.html#adc149342aa9ee01302cac713e95fcb57">cv::phase</a> (const Mat &amp;<a class="el" href="highgui__c_8h.html#ad77deca22f617d3f0e0eb786445689fc">x</a>, const Mat &amp;<a class="el" href="highgui__c_8h.html#a9298c7ad619074f5285b32c6b72bfdea">y</a>, CV_OUT Mat &amp;angle, bool angleInDegrees=false)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">computes angle (angle(i)) of each (x(i), y(i)) vector  <a href="#adc149342aa9ee01302cac713e95fcb57"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">CV_EXPORTS_W void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacecv.html#a3223fa55778440615cd76a01eed68d97">cv::polarToCart</a> (const Mat &amp;magnitude, const Mat &amp;angle, CV_OUT Mat &amp;<a class="el" href="highgui__c_8h.html#ad77deca22f617d3f0e0eb786445689fc">x</a>, CV_OUT Mat &amp;<a class="el" href="highgui__c_8h.html#a9298c7ad619074f5285b32c6b72bfdea">y</a>, bool angleInDegrees=false)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">converts polar coordinates to Cartesian  <a href="#a3223fa55778440615cd76a01eed68d97"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacecv.html#a98e9282d013e32777b73456bb774d4cf">cv::polylines</a> (Mat &amp;img, const Point **pts, const int *npts, int ncontours, bool isClosed, const Scalar &amp;color, int thickness=1, int lineType=8, int shift=0)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">draws one or more polygonal curves  <a href="#a98e9282d013e32777b73456bb774d4cf"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">CV_EXPORTS_W void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacecv.html#ab4590cb42c8e000c857b12ce13b067ec">cv::pow</a> (const Mat &amp;src, double power, CV_OUT Mat &amp;dst)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">raises the input matrix elements to the specified power (b = a**power)  <a href="#ab4590cb42c8e000c857b12ce13b067ec"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">CV_EXPORTS_W void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacecv.html#a9564d5456183b37be3801363c104dfb5">cv::putText</a> (Mat &amp;img, const string &amp;text, Point org, int fontFace, double fontScale, Scalar color, int thickness=1, int linetype=8, bool bottomLeftOrigin=false)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">renders text string in the image  <a href="#a9564d5456183b37be3801363c104dfb5"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">CV_EXPORTS_W void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacecv.html#affe40e88240e6d95fde1f0d7c49a05bc">cv::randn</a> (CV_OUT Mat &amp;dst, const Scalar &amp;mean, const Scalar &amp;stddev)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">fills array with normally-distributed random numbers with the specified mean and the standard deviation  <a href="#affe40e88240e6d95fde1f0d7c49a05bc"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacecv.html#a9d7b672b4b4262913a10d0df7256136c">cv::randShuffle</a> (Mat &amp;dst, double iterFactor=1., RNG *rng=0)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">shuffles the input array elements  <a href="#a9d7b672b4b4262913a10d0df7256136c"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">CV_EXPORTS_W void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacecv.html#a202aa2a83fce84cde1585c1f4c484a5d">cv::randu</a> (CV_OUT Mat &amp;dst, const Scalar &amp;low, const Scalar &amp;high)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">fills array with uniformly-distributed random numbers from the range [low, high)  <a href="#a202aa2a83fce84cde1585c1f4c484a5d"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">CV_EXPORTS_W void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacecv.html#a2a31b41c9fc293c61199c828a5bb96f7">cv::rectangle</a> (Mat &amp;img, Point pt1, Point pt2, const Scalar &amp;color, int thickness=1, int lineType=8, int shift=0)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">draws the rectangle outline or a solid rectangle with the opposite corners pt1 and pt2 in the image  <a href="#a2a31b41c9fc293c61199c828a5bb96f7"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacecv.html#a6072290bc4c00d551aaeca8e82d15870">cv::rectangle</a> (Mat &amp;img, Rect rec, const Scalar &amp;color, int thickness=1, int lineType=8, int shift=0)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">draws the rectangle outline or a solid rectangle covering rec in the image  <a href="#a6072290bc4c00d551aaeca8e82d15870"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">ErrorCallback&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacecv.html#a8cd28eccccb695570cdaf86a572d2c0c">cv::redirectError</a> (ErrorCallback errCallback, void *userdata=0, void **prevUserdata=0)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Sets the new error handler and the optional user data.  <a href="#a8cd28eccccb695570cdaf86a572d2c0c"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">CV_EXPORTS_W void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacecv.html#aa30d7646a887c827af71e06fd390c2ba">cv::reduce</a> (const Mat &amp;src, CV_OUT Mat &amp;dst, int dim, int rtype, int dtype=-1)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">transforms 2D matrix to 1D row or column vector by taking sum, minimum, maximum or mean value over all the rows  <a href="#aa30d7646a887c827af71e06fd390c2ba"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">CV_EXPORTS_W void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacecv.html#a96ba9fa1ab623bfff73d4770717c4a50">cv::repeat</a> (const Mat &amp;src, int ny, int nx, CV_OUT Mat &amp;dst)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">replicates the input matrix the specified number of times in the horizontal and/or vertical direction  <a href="#a96ba9fa1ab623bfff73d4770717c4a50"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">Mat&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacecv.html#a8e9c4ef56a85c58332c63997c10a51d8">cv::repeat</a> (const Mat &amp;src, int ny, int nx)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacecv.html#a72c224ca2e4f11d4c5d8f8b018d9cfd5">cv::scalarToRawData</a> (const Scalar &amp;s, void *buf, int type, int unroll_to=0)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">CV_EXPORTS_W void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacecv.html#a97d6a1d6834b9af9ad954faac01cbce8">cv::scaleAdd</a> (const Mat &amp;src1, double alpha, const Mat &amp;src2, CV_OUT Mat &amp;dst)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">adds scaled array to another one (dst = alpha*src1 + src2)  <a href="#a97d6a1d6834b9af9ad954faac01cbce8"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacecv.html#ae4904ef072dede53cf161d9a6869083f">cv::setBreakOnError</a> (bool flag)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Sets/resets the break-on-error mode.  <a href="#ae4904ef072dede53cf161d9a6869083f"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">CV_EXPORTS_W void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacecv.html#a2ad51d2770ec1c4ef097498754458724">cv::setIdentity</a> (Mat &amp;mtx, const Scalar &amp;s=Scalar(1))</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">initializes scaled identity matrix  <a href="#a2ad51d2770ec1c4ef097498754458724"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacecv.html#ae78625c3c2aa9e0b83ed31b73c6549c0">cv::setNumThreads</a> (int nthreads)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">CV_EXPORTS_W void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacecv.html#ab738cf74be01e01bab8ca875abcf5314">cv::setUseOptimized</a> (bool onoff)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">CV_EXPORTS_W bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacecv.html#ae32334515bdc5f6bf008f240aa081902">cv::solve</a> (const Mat &amp;src1, const Mat &amp;src2, CV_OUT Mat &amp;dst, int <a class="el" href="highgui__c_8h.html#a537e9e30547f68fff6358cc410095bb9">flags</a>=DECOMP_LU)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">solves linear system or a least-square problem  <a href="#ae32334515bdc5f6bf008f240aa081902"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">CV_EXPORTS_W int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacecv.html#a570b5827ca4f8b8dd53368caa0649380">cv::solveCubic</a> (const Mat &amp;coeffs, CV_OUT Mat &amp;roots)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">finds real roots of a cubic polynomial  <a href="#a570b5827ca4f8b8dd53368caa0649380"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">CV_EXPORTS_W double&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacecv.html#a334494c59476da55066c408dbae0bf1a">cv::solvePoly</a> (const Mat &amp;coeffs, CV_OUT Mat &amp;roots, int maxIters=300)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">finds real and complex roots of a polynomial  <a href="#a334494c59476da55066c408dbae0bf1a"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">CV_EXPORTS_W void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacecv.html#af66410d6ee3bba4d9c6628589574f9a9">cv::sort</a> (const Mat &amp;src, CV_OUT Mat &amp;dst, int <a class="el" href="highgui__c_8h.html#a537e9e30547f68fff6358cc410095bb9">flags</a>)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">sorts independently each matrix row or each matrix column  <a href="#af66410d6ee3bba4d9c6628589574f9a9"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">CV_EXPORTS_W void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacecv.html#a223b0de5b1c758cf0a6e850eec8470e3">cv::sortIdx</a> (const Mat &amp;src, CV_OUT Mat &amp;dst, int <a class="el" href="highgui__c_8h.html#a537e9e30547f68fff6358cc410095bb9">flags</a>)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">sorts independently each matrix row or each matrix column  <a href="#a223b0de5b1c758cf0a6e850eec8470e3"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">CV_EXPORTS_W void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacecv.html#aa3f887a0b4f2e42428729da87b302973">cv::split</a> (const Mat &amp;m, vector&lt; Mat &gt; &amp;mv)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">copies each plane of a multi-channel array to a dedicated array  <a href="#aa3f887a0b4f2e42428729da87b302973"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacecv.html#a0547c7fed86152d7e9d0096029c8518a">cv::split</a> (const Mat &amp;src, Mat *mvbegin)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">copies each plane of a multi-channel array to a dedicated array  <a href="#a0547c7fed86152d7e9d0096029c8518a"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">CV_EXPORTS_W void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacecv.html#ad4272ced40e7db7cf6b8e74b1c0c4b89">cv::sqrt</a> (const Mat &amp;src, CV_OUT Mat &amp;dst)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">computes square root of each matrix element (dst = src**0.5)  <a href="#ad4272ced40e7db7cf6b8e74b1c0c4b89"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacecv.html#aff08349a60f8e7b1b7375ec8cccdb834">cv::subtract</a> (const Mat &amp;src1, const Mat &amp;src2, CV_OUT Mat &amp;dst)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">subtracts one matrix from another (dst = src1 - src2)  <a href="#aff08349a60f8e7b1b7375ec8cccdb834"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">CV_EXPORTS_W void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacecv.html#a749cb8a7c9d7c24e49b79e0e4c6baa86">cv::subtract</a> (const Mat &amp;src1, const Scalar &amp;src2, CV_OUT Mat &amp;dst, const Mat &amp;mask=Mat())</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">subtracts scalar from a matrix (dst = src1 - src2)  <a href="#a749cb8a7c9d7c24e49b79e0e4c6baa86"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">CV_EXPORTS_W void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacecv.html#a40a760d078991602107c87cf277be9f7">cv::subtract</a> (const Scalar &amp;src1, const Mat &amp;src2, CV_OUT Mat &amp;dst, const Mat &amp;mask=Mat())</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">subtracts matrix from scalar (dst = src1 - src2)  <a href="#a40a760d078991602107c87cf277be9f7"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">CV_EXPORTS_W void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacecv.html#aea33348fe2f848e1b59bf004c1cdad47">cv::subtract</a> (const Mat &amp;src1, const Mat &amp;src2, CV_OUT Mat &amp;dst, const Mat &amp;mask CV_WRAP_DEFAULT(Mat()))</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">subtracts one matrix from another (dst = src1 - src2)  <a href="#aea33348fe2f848e1b59bf004c1cdad47"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">CV_EXPORTS_W Scalar&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacecv.html#aff9ed3cc703a0ab186cae1dee8a90e6d">cv::sum</a> (const Mat &amp;src)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">computes sum of array elements  <a href="#aff9ed3cc703a0ab186cae1dee8a90e6d"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacecv.html#afbc8f513f40dc1b7c2d48ea6a5a81776">cv::swap</a> (Mat &amp;a, Mat &amp;b)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">swaps two matrices  <a href="#afbc8f513f40dc1b7c2d48ea6a5a81776"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">RNG &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacecv.html#a3161a635d36203f92adadec67b29c2a3">cv::theRNG</a> ()</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">returns the thread-local Random number generator  <a href="#a3161a635d36203f92adadec67b29c2a3"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">WString&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacecv.html#a8c4e113fc7bd605138b5df3008f507dd">cv::toUtf16</a> (const string &amp;str)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">CV_EXPORTS_W Scalar&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacecv.html#a7b4d5d5578899159348cc36db34d4e15">cv::trace</a> (const Mat &amp;mtx)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">computes trace of a matrix  <a href="#a7b4d5d5578899159348cc36db34d4e15"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">CV_EXPORTS_W void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacecv.html#a2fc1afdc86c4b023c530a528d0a8ae3f">cv::transform</a> (const Mat &amp;src, CV_OUT Mat &amp;dst, const Mat &amp;m)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">performs affine transformation of each element of multi-channel input matrix  <a href="#a2fc1afdc86c4b023c530a528d0a8ae3f"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">CV_EXPORTS_W void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacecv.html#a0ef9755551f9bf160a2c4c7775ad1f4c">cv::transpose</a> (const Mat &amp;src, CV_OUT Mat &amp;dst)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">transposes the matrix  <a href="#a0ef9755551f9bf160a2c4c7775ad1f4c"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">CV_EXPORTS_W bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacecv.html#accc4fbc3a4793f2052657076b8fc78c6">cv::useOptimized</a> ()</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacecv.html#a415c53dba6c8ee7ffcf1412247f5389d">cv::vconcat</a> (const Mat &amp;src1, const Mat &amp;src2, Mat &amp;dst)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacecv.html#af5c2608df867b0e10e33abdcb0ed4635">cv::vconcat</a> (const Mat *src, size_t nsrc, Mat &amp;dst)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">CV_EXPORTS_W void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacecv.html#a171018792e47ae164f8ca8e073cef3bb">cv::vconcat</a> (const vector&lt; Mat &gt; &amp;src, CV_OUT Mat &amp;dst)</td></tr>
</table>
<hr/><h2>Define Documentation</h2>
<a class="anchor" id="aebbd3a08c72b75549ea54c4b8fa6fc86"></a><!-- doxytag: member="core.hpp~::__OPENCV_CORE_HPP__" ref="aebbd3a08c72b75549ea54c4b8fa6fc86" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define __OPENCV_CORE_HPP__</td>
        </tr>
      </table>
</div>
<div class="memdoc">

</div>
</div>
<a class="anchor" id="af62bcd90f70e275191ab95136d85906b"></a><!-- doxytag: member="core.hpp~::CV_Assert" ref="af62bcd90f70e275191ab95136d85906b" args="(expr)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define CV_Assert</td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">expr</td><td>)</td>
          <td>&#160;&#160;&#160;if((expr)) ; else cv::error( <a class="el" href="classcv_1_1Exception.html">cv::Exception</a>(CV_StsAssert, #expr, &quot;&quot;, __FILE__, __LINE__) )</td>
        </tr>
      </table>
</div>
<div class="memdoc">

</div>
</div>
<a class="anchor" id="afbcb487cba05bd288dbe18c433de4f6f"></a><!-- doxytag: member="core.hpp~::CV_DbgAssert" ref="afbcb487cba05bd288dbe18c433de4f6f" args="(expr)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define CV_DbgAssert</td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">expr</td><td>)</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

</div>
</div>
<a class="anchor" id="a5b48c333c777666e076bd7052799f891"></a><!-- doxytag: member="core.hpp~::CV_Error" ref="a5b48c333c777666e076bd7052799f891" args="(code, msg)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define CV_Error</td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">code, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">msg&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td>&#160;&#160;&#160;cv::error( <a class="el" href="classcv_1_1Exception.html">cv::Exception</a>(code, msg, &quot;&quot;, __FILE__, __LINE__) )</td>
        </tr>
      </table>
</div>
<div class="memdoc">

</div>
</div>
<a class="anchor" id="a1c0cd6e5bd9a5f915c6cab9c0632f969"></a><!-- doxytag: member="core.hpp~::CV_Error_" ref="a1c0cd6e5bd9a5f915c6cab9c0632f969" args="(code, args)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define CV_Error_</td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">code, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">args&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td>&#160;&#160;&#160;cv::error( <a class="el" href="classcv_1_1Exception.html">cv::Exception</a>(code, cv::format args, &quot;&quot;, __FILE__, __LINE__) )</td>
        </tr>
      </table>
</div>
<div class="memdoc">

</div>
</div>
</div>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
<a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(0)"><span class="SelectionMark">&#160;</span>All</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(1)"><span class="SelectionMark">&#160;</span>Classes</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(2)"><span class="SelectionMark">&#160;</span>Namespaces</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(3)"><span class="SelectionMark">&#160;</span>Files</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(4)"><span class="SelectionMark">&#160;</span>Functions</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(5)"><span class="SelectionMark">&#160;</span>Variables</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(6)"><span class="SelectionMark">&#160;</span>Typedefs</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(7)"><span class="SelectionMark">&#160;</span>Enumerations</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(8)"><span class="SelectionMark">&#160;</span>Enumerator</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(9)"><span class="SelectionMark">&#160;</span>Friends</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(10)"><span class="SelectionMark">&#160;</span>Defines</a></div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<hr class="footer"/><address class="footer"><small>Generated on Wed Mar 28 2012 16:15:17 for opencv by&#160;
<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/></a> 1.7.4 </small></address>
</body>
</html>
