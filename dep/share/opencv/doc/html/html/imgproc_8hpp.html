<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<title>opencv: /home/christophe/src/OpenCV-2.2.0/modules/imgproc/include/opencv2/imgproc/imgproc.hpp File Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css"/>
</head>
<body onload='searchBox.OnSelectItem(0);'>
<!-- Generated by Doxygen 1.7.4 -->
<script type="text/javascript"><!--
var searchBox = new SearchBox("searchBox", "search",false,'Search');
--></script>
<div id="top">
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td style="padding-left: 0.5em;">
   <div id="projectname">opencv&#160;<span id="projectnumber">2.2.0</span></div>
  </td>
 </tr>
 </tbody>
</table>
</div>
  <div id="navrow1" class="tabs">
    <ul class="tablist">
      <li><a href="index.html"><span>Main&#160;Page</span></a></li>
      <li><a href="pages.html"><span>Related&#160;Pages</span></a></li>
      <li><a href="namespaces.html"><span>Namespaces</span></a></li>
      <li><a href="annotated.html"><span>Classes</span></a></li>
      <li class="current"><a href="files.html"><span>Files</span></a></li>
      <li id="searchli">
        <div id="MSearchBox" class="MSearchBoxInactive">
        <span class="left">
          <img id="MSearchSelect" src="search/mag_sel.png"
               onmouseover="return searchBox.OnSearchSelectShow()"
               onmouseout="return searchBox.OnSearchSelectHide()"
               alt=""/>
          <input type="text" id="MSearchField" value="Search" accesskey="S"
               onfocus="searchBox.OnSearchFieldFocus(true)" 
               onblur="searchBox.OnSearchFieldFocus(false)" 
               onkeyup="searchBox.OnSearchFieldChange(event)"/>
          </span><span class="right">
            <a id="MSearchClose" href="javascript:searchBox.CloseResultsWindow()"><img id="MSearchCloseImg" border="0" src="search/close.png" alt=""/></a>
          </span>
        </div>
      </li>
    </ul>
  </div>
  <div id="navrow2" class="tabs2">
    <ul class="tablist">
      <li><a href="files.html"><span>File&#160;List</span></a></li>
      <li><a href="globals.html"><span>File&#160;Members</span></a></li>
    </ul>
  </div>
</div>
<div class="header">
  <div class="summary">
<a href="#nested-classes">Classes</a> &#124;
<a href="#namespaces">Namespaces</a> &#124;
<a href="#enum-members">Enumerations</a> &#124;
<a href="#func-members">Functions</a> &#124;
<a href="#var-members">Variables</a>  </div>
  <div class="headertitle">
<div class="title">/home/christophe/src/OpenCV-2.2.0/modules/imgproc/include/opencv2/imgproc/imgproc.hpp File Reference</div>  </div>
</div>
<div class="contents">

<p>The Image Processing.  
<a href="#details">More...</a></p>

<p><a href="imgproc_8hpp_source.html">Go to the source code of this file.</a></p>
<table class="memberdecls">
<tr><td colspan="2"><h2><a name="nested-classes"></a>
Classes</h2></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcv_1_1BaseColumnFilter.html">cv::BaseColumnFilter</a></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcv_1_1BaseFilter.html">cv::BaseFilter</a></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcv_1_1BaseRowFilter.html">cv::BaseRowFilter</a></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structCvLSHOperations.html">CvLSHOperations</a></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcv_1_1FilterEngine.html">cv::FilterEngine</a></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structlsh__hash.html">lsh_hash</a></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcv_1_1Moments.html">cv::Moments</a></td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">raster image moments  <a href="classcv_1_1Moments.html#details">More...</a><br/></td></tr>
<tr><td colspan="2"><h2><a name="namespaces"></a>
Namespaces</h2></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">namespace &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacecv.html">cv</a></td></tr>
<tr><td colspan="2"><h2><a name="enum-members"></a>
Enumerations</h2></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">enum &#160;</td><td class="memItemRight" valign="bottom">{ <br/>
&#160;&#160;<a class="el" href="namespacecv.html#a52ba1d3917d1be7e2c236bf0c5e5a74aaa1de4cff95e3377d6d0cbe7569bd4e9f">cv::BORDER_REPLICATE</a> = IPL_BORDER_REPLICATE, 
<a class="el" href="namespacecv.html#a52ba1d3917d1be7e2c236bf0c5e5a74aaed2e4346047e265c8c5a6d0276dcd838">cv::BORDER_CONSTANT</a> = IPL_BORDER_CONSTANT, 
<a class="el" href="namespacecv.html#a52ba1d3917d1be7e2c236bf0c5e5a74aa815c8a89b7cb206dcba14d11b7560f4b">cv::BORDER_REFLECT</a> = IPL_BORDER_REFLECT, 
<a class="el" href="namespacecv.html#a52ba1d3917d1be7e2c236bf0c5e5a74aa697c1b011884a7c2bdc0e5caf7955661">cv::BORDER_WRAP</a> = IPL_BORDER_WRAP, 
<br/>
&#160;&#160;<a class="el" href="namespacecv.html#a52ba1d3917d1be7e2c236bf0c5e5a74aab3c5a6143d8120b95005fa7105a10bb4">cv::BORDER_REFLECT_101</a> = IPL_BORDER_REFLECT_101, 
<a class="el" href="namespacecv.html#a52ba1d3917d1be7e2c236bf0c5e5a74aa119fb22eda11675d2e00426d334a1a81">cv::BORDER_REFLECT101</a> = BORDER_REFLECT_101, 
<a class="el" href="namespacecv.html#a52ba1d3917d1be7e2c236bf0c5e5a74aa886a5eb6b466854d63f9e742d5c8eefe">cv::BORDER_TRANSPARENT</a> = IPL_BORDER_TRANSPARENT, 
<a class="el" href="namespacecv.html#a52ba1d3917d1be7e2c236bf0c5e5a74aafe14c13a4ea8b8e3b3ef399013dbae01">cv::BORDER_DEFAULT</a> = BORDER_REFLECT_101, 
<br/>
&#160;&#160;<a class="el" href="namespacecv.html#a52ba1d3917d1be7e2c236bf0c5e5a74aa4fcb77ae62e1e1336c1c2b24a441995c">cv::BORDER_ISOLATED</a> = 16
<br/>
 }</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">various border interpolation methods  <a href="namespacecv.html#a52ba1d3917d1be7e2c236bf0c5e5a74a">More...</a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">enum &#160;</td><td class="memItemRight" valign="bottom">{ <br/>
&#160;&#160;<a class="el" href="namespacecv.html#a58a3bc75c7337534ea9c1697b928cae0a4a8f89a81b41dfedea54e8486aca64bd">cv::KERNEL_GENERAL</a> = 0, 
<a class="el" href="namespacecv.html#a58a3bc75c7337534ea9c1697b928cae0a4b518662ac9e192d941fe3a714eb5e01">cv::KERNEL_SYMMETRICAL</a> = 1, 
<a class="el" href="namespacecv.html#a58a3bc75c7337534ea9c1697b928cae0ac1550d3aa81ed7603c7b8108db71fab7">cv::KERNEL_ASYMMETRICAL</a> = 2, 
<a class="el" href="namespacecv.html#a58a3bc75c7337534ea9c1697b928cae0a39068536a687b7f7f0c242850484fb81">cv::KERNEL_SMOOTH</a> = 4, 
<br/>
&#160;&#160;<a class="el" href="namespacecv.html#a58a3bc75c7337534ea9c1697b928cae0ac9ca87d7ff4e043c8c07b4a49750eafb">cv::KERNEL_INTEGER</a> = 8
<br/>
 }</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">type of the kernel  <a href="namespacecv.html#a58a3bc75c7337534ea9c1697b928cae0">More...</a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">enum &#160;</td><td class="memItemRight" valign="bottom">{ <br/>
&#160;&#160;<a class="el" href="namespacecv.html#a9007b81edae8e7ead89219b316c109fbaa3783a21b429f4c31c178264a0403fcd">cv::MORPH_ERODE</a> = 0, 
<a class="el" href="namespacecv.html#a9007b81edae8e7ead89219b316c109fba2b9f6b6fb168b4d1d5277caebfe7b73d">cv::MORPH_DILATE</a> = 1, 
<a class="el" href="namespacecv.html#a9007b81edae8e7ead89219b316c109fba08d3cc3a2ace00cec488966d31fa29ea">cv::MORPH_OPEN</a> = 2, 
<a class="el" href="namespacecv.html#a9007b81edae8e7ead89219b316c109fba68c4b9c6144a30bcd52d1cdf39bb30e1">cv::MORPH_CLOSE</a> = 3, 
<br/>
&#160;&#160;<a class="el" href="namespacecv.html#a9007b81edae8e7ead89219b316c109fba887efd64e82cee95a62f851c7f3b617b">cv::MORPH_GRADIENT</a> = 4, 
<a class="el" href="namespacecv.html#a9007b81edae8e7ead89219b316c109fbada67be24f4dce6d7e6c57527f8724f3b">cv::MORPH_TOPHAT</a> = 5, 
<a class="el" href="namespacecv.html#a9007b81edae8e7ead89219b316c109fba24d27f56df6b98b1cb92ae8108d4638f">cv::MORPH_BLACKHAT</a> = 6
<br/>
 }</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">type of morphological operation  <a href="namespacecv.html#a9007b81edae8e7ead89219b316c109fb">More...</a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">enum &#160;</td><td class="memItemRight" valign="bottom">{ <a class="el" href="namespacecv.html#ae515fd11d4c0e5b4162440eaf2094e02a260c4cbde19a749726763c01a074c60f">cv::MORPH_RECT</a> = 0, 
<a class="el" href="namespacecv.html#ae515fd11d4c0e5b4162440eaf2094e02a318435753d0b9f7faa241a658ec2e191">cv::MORPH_CROSS</a> = 1, 
<a class="el" href="namespacecv.html#ae515fd11d4c0e5b4162440eaf2094e02a33a3c67a61f349d21c507d05c53a755f">cv::MORPH_ELLIPSE</a> = 2
 }</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">shape of the structuring element  <a href="namespacecv.html#ae515fd11d4c0e5b4162440eaf2094e02">More...</a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">enum &#160;</td><td class="memItemRight" valign="bottom">{ <br/>
&#160;&#160;<a class="el" href="namespacecv.html#a11738a219783c6dc7fdeb093a4a87c0faa5521d8e080972c762467c45f3b70e6c">cv::INTER_NEAREST</a> = 0, 
<a class="el" href="namespacecv.html#a11738a219783c6dc7fdeb093a4a87c0fac97d8e4880d8b5d509e96825c7522deb">cv::INTER_LINEAR</a> = 1, 
<a class="el" href="namespacecv.html#a11738a219783c6dc7fdeb093a4a87c0fa55e404e7fa9684af79fe9827f36a5dc1">cv::INTER_CUBIC</a> = 2, 
<a class="el" href="namespacecv.html#a11738a219783c6dc7fdeb093a4a87c0facf959dca2480cc694ca016b81b442ceb">cv::INTER_AREA</a> = 3, 
<br/>
&#160;&#160;<a class="el" href="namespacecv.html#a11738a219783c6dc7fdeb093a4a87c0fac6c578caa97f2d00f82bac879cf3c781">cv::INTER_LANCZOS4</a> = 4, 
<a class="el" href="namespacecv.html#a11738a219783c6dc7fdeb093a4a87c0fa49bb9f818707a31ae1f19158b60f7112">cv::INTER_MAX</a> = 7, 
<a class="el" href="namespacecv.html#a11738a219783c6dc7fdeb093a4a87c0faa48be1c433186c4eae1ea86aa0ca75ba">cv::WARP_INVERSE_MAP</a> = 16
<br/>
 }</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">interpolation algorithm  <a href="namespacecv.html#a11738a219783c6dc7fdeb093a4a87c0f">More...</a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">enum &#160;</td><td class="memItemRight" valign="bottom">{ <a class="el" href="namespacecv.html#a04495204613753c836e07d31c575bf3ba9ce4fddaf7714ea113a8a086d1d4b7f9">cv::INTER_BITS</a> = 5, 
<a class="el" href="namespacecv.html#a04495204613753c836e07d31c575bf3ba5d3f110270a147224feaabac0c7a480b">cv::INTER_BITS2</a> = INTER_BITS*2, 
<a class="el" href="namespacecv.html#a04495204613753c836e07d31c575bf3ba2dee31b51b2c400c35a31bf24f8cd809">cv::INTER_TAB_SIZE</a> = (1&lt;&lt;INTER_BITS), 
<a class="el" href="namespacecv.html#a04495204613753c836e07d31c575bf3babdbe1089b768d20af013c344bcac74cf">cv::INTER_TAB_SIZE2</a> = INTER_TAB_SIZE*INTER_TAB_SIZE
 }</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">enum &#160;</td><td class="memItemRight" valign="bottom">{ <br/>
&#160;&#160;<a class="el" href="namespacecv.html#a1d479d51825779352b0225bba25278afa147222a96556ebc1d948b372bcd7ac59">cv::THRESH_BINARY</a> = 0, 
<a class="el" href="namespacecv.html#a1d479d51825779352b0225bba25278afa19120b1a11d8067576cc24f4d2f03754">cv::THRESH_BINARY_INV</a> = 1, 
<a class="el" href="namespacecv.html#a1d479d51825779352b0225bba25278afac7e89a5e95490116e7d2082b3096b2b8">cv::THRESH_TRUNC</a> = 2, 
<a class="el" href="namespacecv.html#a1d479d51825779352b0225bba25278afa0e50a338a4b711a8c48f06a6b105dd98">cv::THRESH_TOZERO</a> = 3, 
<br/>
&#160;&#160;<a class="el" href="namespacecv.html#a1d479d51825779352b0225bba25278afa47518a30aae90d799035bdcf0bb39a50">cv::THRESH_TOZERO_INV</a> = 4, 
<a class="el" href="namespacecv.html#a1d479d51825779352b0225bba25278afa8e723ef461a5349c391032aee325fe15">cv::THRESH_MASK</a> = 7, 
<a class="el" href="namespacecv.html#a1d479d51825779352b0225bba25278afa95251923e8e22f368ffa86ba8bce87ff">cv::THRESH_OTSU</a> = 8
<br/>
 }</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">type of the threshold operation  <a href="namespacecv.html#a1d479d51825779352b0225bba25278af">More...</a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">enum &#160;</td><td class="memItemRight" valign="bottom">{ <a class="el" href="namespacecv.html#a904c71f1f5b910a0ae1048b9e8dd0603ad0c5199ae8637a6b195062fea4789fa9">cv::ADAPTIVE_THRESH_MEAN_C</a> = 0, 
<a class="el" href="namespacecv.html#a904c71f1f5b910a0ae1048b9e8dd0603af262a01e7a3f112bbab4e8d8e28182dd">cv::ADAPTIVE_THRESH_GAUSSIAN_C</a> = 1
 }</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">adaptive threshold algorithm  <a href="namespacecv.html#a904c71f1f5b910a0ae1048b9e8dd0603">More...</a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">enum &#160;</td><td class="memItemRight" valign="bottom">{ <a class="el" href="namespacecv.html#abbf106f6cb6a058c7ee194dc14fe39b1aad55e201c84b7c538455a69153d5e676">cv::PROJ_SPHERICAL_ORTHO</a> =  0, 
<a class="el" href="namespacecv.html#abbf106f6cb6a058c7ee194dc14fe39b1a62d8708c29117854d6903d8e1155d8c0">cv::PROJ_SPHERICAL_EQRECT</a> =  1
 }</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">enum &#160;</td><td class="memItemRight" valign="bottom">{ <a class="el" href="namespacecv.html#aa7b94c52226125d4024580c3699ce4a3a889f1ce109543e8aed80a7abbc6dcb39">cv::GC_BGD</a> =  0, 
<a class="el" href="namespacecv.html#aa7b94c52226125d4024580c3699ce4a3a4757c1f0587bcf6e53e86dee7689a649">cv::GC_FGD</a> =  1, 
<a class="el" href="namespacecv.html#aa7b94c52226125d4024580c3699ce4a3af748414821c7f39fab3493f9eed1eedf">cv::GC_PR_BGD</a> =  2, 
<a class="el" href="namespacecv.html#aa7b94c52226125d4024580c3699ce4a3ad33184b73cb87e08d29e0a3411b7c863">cv::GC_PR_FGD</a> =  3
 }</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">class of the pixel in GrabCut algorithm  <a href="namespacecv.html#aa7b94c52226125d4024580c3699ce4a3">More...</a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">enum &#160;</td><td class="memItemRight" valign="bottom">{ <a class="el" href="namespacecv.html#ada3c4e6ca936e43ff390e61b5629cfd8a5f8853c1e5a89c4aa2687d1f78a7e550">cv::GC_INIT_WITH_RECT</a> =  0, 
<a class="el" href="namespacecv.html#ada3c4e6ca936e43ff390e61b5629cfd8ab01527c7effb50fd1c54d8c4e671ed22">cv::GC_INIT_WITH_MASK</a> =  1, 
<a class="el" href="namespacecv.html#ada3c4e6ca936e43ff390e61b5629cfd8aef3752e3c27c4af9445d0b5590b6aa05">cv::GC_EVAL</a> =  2
 }</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">GrabCut algorithm flags.  <a href="namespacecv.html#ada3c4e6ca936e43ff390e61b5629cfd8">More...</a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">enum &#160;</td><td class="memItemRight" valign="bottom">{ <a class="el" href="namespacecv.html#a480a670b217e98a92e19f7d3ea0e2ac6a05e763003a805e6c11c673a9f4ba7d07">cv::INPAINT_NS</a> = 0, 
<a class="el" href="namespacecv.html#a480a670b217e98a92e19f7d3ea0e2ac6a892824c38e258feb5e72f308a358d52e">cv::INPAINT_TELEA</a> = 1
 }</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">the inpainting algorithm  <a href="namespacecv.html#a480a670b217e98a92e19f7d3ea0e2ac6">More...</a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">enum &#160;</td><td class="memItemRight" valign="bottom">{ <a class="el" href="namespacecv.html#a3489c40a2fb178c477302403ec5cc1dba8aafb7a6a87df91c7624d44f4b092fe3">cv::FLOODFILL_FIXED_RANGE</a> =  1 &lt;&lt; 16, 
<a class="el" href="namespacecv.html#a3489c40a2fb178c477302403ec5cc1dba7161dca1d0b9e84e5208c7e8021b4d3a">cv::FLOODFILL_MASK_ONLY</a> =  1 &lt;&lt; 17
 }</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">enum &#160;</td><td class="memItemRight" valign="bottom">{ <br/>
&#160;&#160;<a class="el" href="namespacecv.html#a92853c869244c79b75b3710017dd4f31ab65c042ed62c9e9e095a1e7e41fe2773">cv::TM_SQDIFF</a> = 0, 
<a class="el" href="namespacecv.html#a92853c869244c79b75b3710017dd4f31a5382c8f9df87e87cf1e9f9927dc3bc31">cv::TM_SQDIFF_NORMED</a> = 1, 
<a class="el" href="namespacecv.html#a92853c869244c79b75b3710017dd4f31a5be00b45a4d99b5e42625b4400bfde65">cv::TM_CCORR</a> = 2, 
<a class="el" href="namespacecv.html#a92853c869244c79b75b3710017dd4f31af9c3ab9296f597ea71f056399a5831da">cv::TM_CCORR_NORMED</a> = 3, 
<br/>
&#160;&#160;<a class="el" href="namespacecv.html#a92853c869244c79b75b3710017dd4f31ac5babb7dfda59544e3e31ea928f8cb16">cv::TM_CCOEFF</a> = 4, 
<a class="el" href="namespacecv.html#a92853c869244c79b75b3710017dd4f31ac6677e2af5e0fae82cc5339bfaef5038">cv::TM_CCOEFF_NORMED</a> = 5
<br/>
 }</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">type of the template matching operation  <a href="namespacecv.html#a92853c869244c79b75b3710017dd4f31">More...</a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">enum &#160;</td><td class="memItemRight" valign="bottom">{ <a class="el" href="namespacecv.html#abf14a404911964f7d6826255ac6ec175aa7adc6d6608609fd84650f71b954b981">cv::RETR_EXTERNAL</a> = 0, 
<a class="el" href="namespacecv.html#abf14a404911964f7d6826255ac6ec175a48b9c2cb1056f775ae50bb68288b875e">cv::RETR_LIST</a> = 1, 
<a class="el" href="namespacecv.html#abf14a404911964f7d6826255ac6ec175a7d1d4b509fb2a9a8dc2f960357748752">cv::RETR_CCOMP</a> = 2, 
<a class="el" href="namespacecv.html#abf14a404911964f7d6826255ac6ec175ab10df56aed56c89a026580adc9431f58">cv::RETR_TREE</a> = 3
 }</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">mode of the contour retrieval algorithm  <a href="namespacecv.html#abf14a404911964f7d6826255ac6ec175">More...</a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">enum &#160;</td><td class="memItemRight" valign="bottom">{ <a class="el" href="namespacecv.html#af29e0fa734a4a98dec5801058dfdfaadaf7d9a3582d021d5dadcb0e37201a62f8">cv::CHAIN_APPROX_NONE</a> = 0, 
<a class="el" href="namespacecv.html#af29e0fa734a4a98dec5801058dfdfaada5f2883048e654999209f88ba04c302f5">cv::CHAIN_APPROX_SIMPLE</a> = 1, 
<a class="el" href="namespacecv.html#af29e0fa734a4a98dec5801058dfdfaadad29171855734b1cf69fb6653c5d1db35">cv::CHAIN_APPROX_TC89_L1</a> = 2, 
<a class="el" href="namespacecv.html#af29e0fa734a4a98dec5801058dfdfaada867e7a9ab72c8199a60e2d595d1078a3">cv::CHAIN_APPROX_TC89_KCOS</a> = 3
 }</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">the contour approximation algorithm  <a href="namespacecv.html#af29e0fa734a4a98dec5801058dfdfaad">More...</a><br/></td></tr>
<tr><td colspan="2"><h2><a name="func-members"></a>
Functions</h2></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">CV_EXPORTS_W void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacecv.html#a740b44406af6916f1a9b07f930129bba">cv::accumulate</a> (const Mat &amp;src, CV_IN_OUT Mat &amp;dst, const Mat &amp;mask=Mat())</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">adds image to the accumulator (dst += src). Unlike <a class="el" href="namespacecv.html#a5fe1c189a97c40a07be2b31a7bc90e9e" title="adds one matrix to another (dst = src1 + src2)">cv::add</a>, dst and src can have different types.  <a href="#a740b44406af6916f1a9b07f930129bba"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">CV_EXPORTS_W void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacecv.html#aba08406f0dc40c93cf052354c7599493">cv::accumulateProduct</a> (const Mat &amp;src1, const Mat &amp;src2, CV_IN_OUT Mat &amp;dst, const Mat &amp;mask=Mat())</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">adds product of the 2 images to the accumulator (dst += src1*src2).  <a href="#aba08406f0dc40c93cf052354c7599493"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">CV_EXPORTS_W void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacecv.html#a4d3c5f17ef9580c6fe56f991befc2a09">cv::accumulateSquare</a> (const Mat &amp;src, CV_IN_OUT Mat &amp;dst, const Mat &amp;mask=Mat())</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">adds squared src image to the accumulator (dst += src*src).  <a href="#a4d3c5f17ef9580c6fe56f991befc2a09"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">CV_EXPORTS_W void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacecv.html#a130dfaf5df818e18460f751eb1d4b8bb">cv::accumulateWeighted</a> (const Mat &amp;src, CV_IN_OUT Mat &amp;dst, double alpha, const Mat &amp;mask=Mat())</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">updates the running average (dst = dst*(1-alpha) + src*alpha)  <a href="#a130dfaf5df818e18460f751eb1d4b8bb"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">CV_EXPORTS_W void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacecv.html#a78ef63ab064e56a36afe8a836a7a5f53">cv::adaptiveThreshold</a> (const Mat &amp;src, CV_OUT Mat &amp;dst, double maxValue, int adaptiveMethod, int thresholdType, int blockSize, double C)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">applies variable (adaptive) threshold to the image  <a href="#a78ef63ab064e56a36afe8a836a7a5f53"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacecv.html#a3abcbc4abd749aacfa474489dfdfd829">cv::approxPolyDP</a> (const Mat &amp;curve, CV_OUT vector&lt; Point &gt; &amp;approxCurve, double epsilon, bool closed)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">approximates contour or a curve using Douglas-Peucker algorithm  <a href="#a3abcbc4abd749aacfa474489dfdfd829"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">CV_EXPORTS_W double&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacecv.html#a1751dc660d545371dd51d273cda84935">cv::arcLength</a> (const Mat &amp;curve, bool closed)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">computes the contour perimeter (closed=true) or a curve length  <a href="#a1751dc660d545371dd51d273cda84935"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">CV_EXPORTS_W void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacecv.html#ad09b414b440b2da71d9f28d424691ae9">cv::bilateralFilter</a> (const Mat &amp;src, CV_OUT Mat &amp;dst, int d, double sigmaColor, double sigmaSpace, int borderType=BORDER_DEFAULT)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">smooths the image using bilateral filter  <a href="#ad09b414b440b2da71d9f28d424691ae9"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">CV_EXPORTS_W void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacecv.html#a82db1e6a4a5f33b1532d8f0156944f5c">cv::blur</a> (const Mat &amp;src, CV_OUT Mat &amp;dst, Size ksize, Point anchor=Point(-1,-1), int borderType=BORDER_DEFAULT)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">a synonym for normalized box filter  <a href="#a82db1e6a4a5f33b1532d8f0156944f5c"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">CV_EXPORTS_W int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacecv.html#a02bab067ecd97b1699315ad7600e52b2">cv::borderInterpolate</a> (int p, int len, int borderType)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">1D interpolation function: returns coordinate of the "donor" pixel for the specified location p.  <a href="#a02bab067ecd97b1699315ad7600e52b2"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">CV_EXPORTS_W Rect&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacecv.html#a7e5cf1fdacacfbd0a0deb7ca015ca56d">cv::boundingRect</a> (const Mat &amp;points)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">computes the bounding rectangle for a contour  <a href="#a7e5cf1fdacacfbd0a0deb7ca015ca56d"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">CV_EXPORTS_W void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacecv.html#af53d67495bab23cb6e1e1709b93b7203">cv::boxFilter</a> (const Mat &amp;src, CV_OUT Mat &amp;dst, int ddepth, Size ksize, Point anchor=Point(-1,-1), bool normalize=true, int borderType=BORDER_DEFAULT)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">smooths the image using the box filter. Each pixel is processed in O(1) time  <a href="#af53d67495bab23cb6e1e1709b93b7203"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacecv.html#a3d3a551453b20bdf97e54f7fe2031f30">cv::buildPyramid</a> (const Mat &amp;src, CV_OUT vector&lt; Mat &gt; &amp;dst, int maxlevel)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">builds the gaussian pyramid using <a class="el" href="namespacecv.html#a29689a8c0bb345ee796ffff501e11e1b" title="smooths and downsamples the image">pyrDown()</a> as a basic operation  <a href="#a3d3a551453b20bdf97e54f7fe2031f30"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacecv.html#a77bced12a94797fa94e2b494397a6370">cv::calcBackProject</a> (const Mat *images, int nimages, const int *channels, const Mat &amp;hist, Mat &amp;backProject, const float **ranges, double scale=1, bool uniform=true)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">computes back projection for the set of images  <a href="#a77bced12a94797fa94e2b494397a6370"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacecv.html#afb61f2ae09bebf287d56c0cac2aeba45">cv::calcBackProject</a> (const Mat *images, int nimages, const int *channels, const SparseMat &amp;hist, Mat &amp;backProject, const float **ranges, double scale=1, bool uniform=true)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">computes back projection for the set of images  <a href="#afb61f2ae09bebf287d56c0cac2aeba45"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacecv.html#a90cdef93073dc518e45c834c75b5873b">cv::calcHist</a> (const Mat *images, int nimages, const int *channels, const Mat &amp;mask, SparseMat &amp;hist, int dims, const int *histSize, const float **ranges, bool uniform=true, bool accumulate=false)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">computes the joint sparse histogram for a set of images.  <a href="#a90cdef93073dc518e45c834c75b5873b"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacecv.html#afc2ecb4e2fcc45e0dab5f7ecc7f7648e">cv::calcHist</a> (const Mat *images, int nimages, const int *channels, const Mat &amp;mask, Mat &amp;hist, int dims, const int *histSize, const float **ranges, bool uniform=true, bool accumulate=false)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">computes the joint dense histogram for a set of images.  <a href="#afc2ecb4e2fcc45e0dab5f7ecc7f7648e"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">CV_EXPORTS_W double&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacecv.html#a9651092b23d7c7fff98611d804a2807e">cv::compareHist</a> (const Mat &amp;H1, const Mat &amp;H2, int method)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">compares two histograms stored in dense arrays  <a href="#a9651092b23d7c7fff98611d804a2807e"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">double&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacecv.html#a41a249ba9a536bf2b47e95f8c7dd42b0">cv::compareHist</a> (const SparseMat &amp;H1, const SparseMat &amp;H2, int method)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">compares two histograms stored in sparse arrays  <a href="#a41a249ba9a536bf2b47e95f8c7dd42b0"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">CV_EXPORTS_W double&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacecv.html#a6fe75c58918551a8daf20795e7c484c8">cv::contourArea</a> (const Mat &amp;contour, bool oriented=false)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">computes the contour area  <a href="#a6fe75c58918551a8daf20795e7c484c8"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">CV_EXPORTS_W void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacecv.html#a22066e2cd947ddee73907d0056acb6a7">cv::convertMaps</a> (const Mat &amp;map1, const Mat &amp;map2, CV_OUT Mat &amp;dstmap1, CV_OUT Mat &amp;dstmap2, int dstmap1type, bool nninterpolation=false)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">converts maps for remap from floating-point to fixed-point format or backwards  <a href="#a22066e2cd947ddee73907d0056acb6a7"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacecv.html#a25cbe686259ac7ab698dc0908399c49f">cv::convexHull</a> (const Mat &amp;points, CV_OUT vector&lt; int &gt; &amp;hull, bool clockwise=false)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">computes convex hull for a set of 2D points.  <a href="#a25cbe686259ac7ab698dc0908399c49f"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacecv.html#a829ab02e3bf722b9f32830bec6b8e12b">cv::convexHull</a> (const Mat &amp;points, CV_OUT vector&lt; Point &gt; &amp;hull, bool clockwise=false)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">computes convex hull for a set of 2D points.  <a href="#a829ab02e3bf722b9f32830bec6b8e12b"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">CV_EXPORTS_W void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacecv.html#a04ba9fa31d5e72e73d340552001172ff">cv::copyMakeBorder</a> (const Mat &amp;src, CV_OUT Mat &amp;dst, int top, int bottom, int left, int right, int borderType, const Scalar &amp;value=Scalar())</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">copies 2D array to a larger destination array with extrapolation of the outer part of src using the specified border mode  <a href="#a04ba9fa31d5e72e73d340552001172ff"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">CV_EXPORTS_W void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacecv.html#a21bb4fec939f20577c63f85beb54f375">cv::cornerEigenValsAndVecs</a> (const Mat &amp;src, CV_OUT Mat &amp;dst, int blockSize, int ksize, int borderType=BORDER_DEFAULT)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">computes both eigenvalues and the eigenvectors of 2x2 derivative covariation matrix at each pixel. The output is stored as 6-channel matrix.  <a href="#a21bb4fec939f20577c63f85beb54f375"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">CV_EXPORTS_W void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacecv.html#a3e8d4390885e0a7bb45d74882c9d3b00">cv::cornerHarris</a> (const Mat &amp;src, CV_OUT Mat &amp;dst, int blockSize, int ksize, double k, int borderType=BORDER_DEFAULT)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">computes Harris cornerness criteria at each image pixel  <a href="#a3e8d4390885e0a7bb45d74882c9d3b00"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">CV_EXPORTS_W void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacecv.html#a2cfad4530143fae716a3bc8edf042ceb">cv::cornerMinEigenVal</a> (const Mat &amp;src, CV_OUT Mat &amp;dst, int blockSize, int ksize=3, int borderType=BORDER_DEFAULT)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">computes minimum eigen value of 2x2 derivative covariation matrix at each pixel - the cornerness criteria  <a href="#a2cfad4530143fae716a3bc8edf042ceb"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacecv.html#a70a02beefb611090d61b6bf1ba15cfcd">cv::cornerSubPix</a> (const Mat &amp;image, vector&lt; Point2f &gt; &amp;corners, Size winSize, Size zeroZone, TermCriteria criteria)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">adjusts the corner locations with sub-pixel accuracy to maximize the certain cornerness criteria  <a href="#a70a02beefb611090d61b6bf1ba15cfcd"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">Ptr&lt; FilterEngine &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacecv.html#a894de0dfe3531bd92d1f6f5ea0b212da">cv::createBoxFilter</a> (int srcType, int dstType, Size ksize, Point anchor=Point(-1,-1), bool normalize=true, int borderType=BORDER_DEFAULT)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">returns box filter engine  <a href="#a894de0dfe3531bd92d1f6f5ea0b212da"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">Ptr&lt; FilterEngine &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacecv.html#aec7872121272402263cc1cc7e87e17da">cv::createDerivFilter</a> (int srcType, int dstType, int dx, int dy, int ksize, int borderType=BORDER_DEFAULT)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">returns filter engine for the generalized Sobel operator  <a href="#aec7872121272402263cc1cc7e87e17da"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">Ptr&lt; FilterEngine &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacecv.html#afab19870898b19b82cb03b8df920993c">cv::createGaussianFilter</a> (int type, Size ksize, double sigma1, double sigma2=0, int borderType=BORDER_DEFAULT)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">returns the Gaussian filter engine  <a href="#afab19870898b19b82cb03b8df920993c"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">Ptr&lt; FilterEngine &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacecv.html#aa922d71e15110483ef0e7ae308e1f458">cv::createLinearFilter</a> (int srcType, int dstType, const Mat &amp;kernel, Point _anchor=Point(-1,-1), double delta=0, int _rowBorderType=BORDER_DEFAULT, int _columnBorderType=-1, const Scalar &amp;_borderValue=Scalar())</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">returns the non-separable linear filter engine  <a href="#aa922d71e15110483ef0e7ae308e1f458"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">Ptr&lt; FilterEngine &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacecv.html#a05de78ea0288f903b01725783d2060fb">cv::createMorphologyFilter</a> (int op, int type, const Mat &amp;kernel, Point anchor=Point(-1,-1), int _rowBorderType=BORDER_CONSTANT, int _columnBorderType=-1, const Scalar &amp;_borderValue=morphologyDefaultBorderValue())</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">returns morphological filter engine. Only MORPH_ERODE and MORPH_DILATE are supported.  <a href="#a05de78ea0288f903b01725783d2060fb"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">Ptr&lt; FilterEngine &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacecv.html#a4e386d07c5e1201fe3cd7cd096c9ee83">cv::createSeparableLinearFilter</a> (int srcType, int dstType, const Mat &amp;rowKernel, const Mat &amp;columnKernel, Point _anchor=Point(-1,-1), double delta=0, int _rowBorderType=BORDER_DEFAULT, int _columnBorderType=-1, const Scalar &amp;_borderValue=Scalar())</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">returns the separable linear filter engine  <a href="#a4e386d07c5e1201fe3cd7cd096c9ee83"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacecv.html#a24eadcc993138a7abd861b67c36856e4">cv::CV_EXPORTS_AS</a> (canny) void Canny(const Mat &amp;image</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">applies Canny edge detector and produces the edge map.  <a href="#a24eadcc993138a7abd861b67c36856e4"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacecv.html#a6f166dab565a0403e977250b0ff659cf">cv::CV_EXPORTS_AS</a> (houghLines) void HoughLines(const Mat &amp;image</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">finds lines in the black-n-white image using the standard or pyramid Hough transform  <a href="#a6f166dab565a0403e977250b0ff659cf"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacecv.html#aff221553e5e6d7cc13550de2350314ca">cv::CV_EXPORTS_AS</a> (houghLinesP) void HoughLinesP(Mat &amp;image</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">finds line segments in the black-n-white image using probabalistic Hough transform  <a href="#aff221553e5e6d7cc13550de2350314ca"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacecv.html#ae6b5e1ec7eed1378c457df845cf1c0f1">cv::CV_EXPORTS_AS</a> (houghCircles) void HoughCircles(const Mat &amp;image</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">finds circles in the grayscale image using 2+1 gradient Hough transform  <a href="#ae6b5e1ec7eed1378c457df845cf1c0f1"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacecv.html#aa75a86c4d96b627d8c4b4c382c97ca06">cv::CV_EXPORTS_AS</a> (floodFillMask) int floodFill(Mat &amp;image</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">fills the semi-uniform image region and/or the mask starting from the specified seed point  <a href="#aa75a86c4d96b627d8c4b4c382c97ca06"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacecv.html#ab7f3a4da7a367ff4d2be4f171a39b85f">cv::CV_EXPORTS_AS</a> (gaussianBlur) void GaussianBlur(const Mat &amp;src</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">smooths the image using Gaussian filter.  <a href="#ab7f3a4da7a367ff4d2be4f171a39b85f"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacecv.html#ab0ddf67520e5c6447040016e17cee4d1">cv::CV_EXPORTS_AS</a> (integral2) void integral(const Mat &amp;src</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">computes the integral image and integral for the squared image  <a href="#ab0ddf67520e5c6447040016e17cee4d1"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacecv.html#abc445bef5d067d19905335d6962756aa">cv::CV_EXPORTS_AS</a> (integral3) void integral(const Mat &amp;src</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">computes the integral image, integral for the squared image and the tilted integral image  <a href="#abc445bef5d067d19905335d6962756aa"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacecv.html#afffef390dcb827c815b317dd5740605a">cv::CV_EXPORTS_AS</a> (sobel) void Sobel(const Mat &amp;src</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">applies generalized Sobel operator to the image  <a href="#afffef390dcb827c815b317dd5740605a"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacecv.html#a0022ea40432148ae16ddc407637d1314">cv::CV_EXPORTS_AS</a> (scharr) void Scharr(const Mat &amp;src</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">applies the vertical or horizontal Scharr operator to the image  <a href="#a0022ea40432148ae16ddc407637d1314"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacecv.html#aa1c1e6bea2b79b2f0e0619908880a5f2">cv::CV_EXPORTS_AS</a> (laplacian) void Laplacian(const Mat &amp;src</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">applies Laplacian operator to the image  <a href="#aa1c1e6bea2b79b2f0e0619908880a5f2"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">CV_EXPORTS_W void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacecv.html#aa44465aa47d0548bb6486f1bc2cb9dc3">cv::cvtColor</a> (const Mat &amp;src, CV_OUT Mat &amp;dst, int code, int dstCn=0)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">converts image from one color space to another  <a href="#aa44465aa47d0548bb6486f1bc2cb9dc3"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">CV_EXPORTS_W void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacecv.html#a7433ad9d53175a769fae7653f2ac7a39">cv::dilate</a> (const Mat &amp;src, CV_OUT Mat &amp;dst, const Mat &amp;kernel, Point anchor=Point(-1,-1), int iterations=1, int borderType=BORDER_CONSTANT, const Scalar &amp;borderValue=morphologyDefaultBorderValue())</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">dilates the image (applies the local maximum operator)  <a href="#a7433ad9d53175a769fae7653f2ac7a39"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">CV_EXPORTS_W void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacecv.html#ac3d1f5aa40a2dcb384387560e13e32ca">cv::distanceTransform</a> (const Mat &amp;src, CV_OUT Mat &amp;dst, int distanceType, int maskSize)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">computes the distance transform map  <a href="#ac3d1f5aa40a2dcb384387560e13e32ca"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacecv.html#aa7a26a1f08361acc8de5f1e4fda2be81">cv::distanceTransform</a> (const Mat &amp;src, CV_OUT Mat &amp;dst, Mat &amp;labels, int distanceType, int maskSize)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">builds the discrete Voronoi diagram  <a href="#aa7a26a1f08361acc8de5f1e4fda2be81"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacecv.html#a0c3217eec413f4b37a4c9931d46eeb91">cv::drawContours</a> (Mat &amp;image, const vector&lt; vector&lt; Point &gt; &gt; &amp;contours, int contourIdx, const Scalar &amp;color, int thickness=1, int lineType=8, const vector&lt; Vec4i &gt; &amp;hierarchy=vector&lt; Vec4i &gt;(), int maxLevel=INT_MAX, Point offset=Point())</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">draws contours in the image  <a href="#a0c3217eec413f4b37a4c9931d46eeb91"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">CV_EXPORTS_W void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacecv.html#a41d8a37488a5cd641b1bed27c5958f1b">cv::equalizeHist</a> (const Mat &amp;src, CV_OUT Mat &amp;dst)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">normalizes the grayscale image brightness and contrast by normalizing its histogram  <a href="#a41d8a37488a5cd641b1bed27c5958f1b"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">CV_EXPORTS_W void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacecv.html#a597dd4002ecbdc73125ba15d3647872c">cv::erode</a> (const Mat &amp;src, CV_OUT Mat &amp;dst, const Mat &amp;kernel, Point anchor=Point(-1,-1), int iterations=1, int borderType=BORDER_CONSTANT, const Scalar &amp;borderValue=morphologyDefaultBorderValue())</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">erodes the image (applies the local minimum operator)  <a href="#a597dd4002ecbdc73125ba15d3647872c"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">CV_EXPORTS_W Mat&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacecv.html#a034304fecb38ec5f63515df5f54916a7">cv::estimateRigidTransform</a> (const Mat &amp;A, const Mat &amp;B, bool fullAffine)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">estimates the best-fit affine transformation that maps one 2D point set to another or one image to another.  <a href="#a034304fecb38ec5f63515df5f54916a7"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">CV_EXPORTS_W void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacecv.html#a64156caf15cb58799128d7f05da87a47">cv::filter2D</a> (const Mat &amp;src, CV_OUT Mat &amp;dst, int ddepth, const Mat &amp;kernel, Point anchor=Point(-1,-1), double delta=0, int borderType=BORDER_DEFAULT)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">applies non-separable 2D linear filter to the image  <a href="#a64156caf15cb58799128d7f05da87a47"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacecv.html#aa3aa867cf722e50fc36b3be102edc5c7">cv::findContours</a> (Mat &amp;image, CV_OUT vector&lt; vector&lt; Point &gt; &gt; &amp;contours, int mode, int method, Point offset=Point())</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">retrieves contours from black-n-white image.  <a href="#aa3aa867cf722e50fc36b3be102edc5c7"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacecv.html#a63eae5b67bc512f6067c57013c4ee981">cv::findContours</a> (Mat &amp;image, CV_OUT vector&lt; vector&lt; Point &gt; &gt; &amp;contours, vector&lt; Vec4i &gt; &amp;hierarchy, int mode, int method, Point offset=Point())</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">retrieves contours and the hierarchical information from black-n-white image.  <a href="#a63eae5b67bc512f6067c57013c4ee981"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">CV_EXPORTS_W RotatedRect&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacecv.html#a064c4fb9e339ce9365ab1e44bbb47a18">cv::fitEllipse</a> (const Mat &amp;points)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">fits ellipse to the set of 2D points  <a href="#a064c4fb9e339ce9365ab1e44bbb47a18"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacecv.html#ad3de932d977e1178e0bd36d6fe2bdfaa">cv::fitLine</a> (const Mat &amp;points, CV_OUT Vec4f &amp;line, int distType, double <a class="el" href="highgui__c_8h.html#a2fad04a6d56e23dd58d9ebbcffae688f">param</a>, double reps, double aeps)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">fits line to the set of 2D points using M-estimator algorithm  <a href="#ad3de932d977e1178e0bd36d6fe2bdfaa"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">CV_EXPORTS_W int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacecv.html#a6655ca4250e41a9b706152b5dfc793de">cv::floodFill</a> (Mat &amp;image, Point seedPoint, Scalar newVal, CV_OUT Rect *rect=0, Scalar loDiff=Scalar(), Scalar upDiff=Scalar(), int <a class="el" href="highgui__c_8h.html#a537e9e30547f68fff6358cc410095bb9">flags</a>=4)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">fills the semi-uniform image region starting from the specified seed point  <a href="#a6655ca4250e41a9b706152b5dfc793de"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">Mat&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacecv.html#a8f6d378f9f8eebb5cb55cd3ae295a999">cv::getAffineTransform</a> (const Point2f src[], const Point2f dst[])</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">returns 2x3 affine transformation for the corresponding 3 point pairs.  <a href="#a8f6d378f9f8eebb5cb55cd3ae295a999"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">Ptr&lt; BaseColumnFilter &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacecv.html#a1ee3d458c1048def5dd633075cf90fbe">cv::getColumnSumFilter</a> (int sumType, int dstType, int ksize, int anchor=-1, double scale=1)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">returns vertical 1D box filter  <a href="#a1ee3d458c1048def5dd633075cf90fbe"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">CV_EXPORTS_W Mat&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacecv.html#a945429712b41abf67df549eb458f6b53">cv::getDefaultNewCameraMatrix</a> (const Mat &amp;cameraMatrix, Size imgsize=Size(), bool centerPrincipalPoint=false)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">returns the default new camera matrix (by default it is the same as cameraMatrix unless centerPricipalPoint=true)  <a href="#a945429712b41abf67df549eb458f6b53"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">CV_EXPORTS_W void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacecv.html#a90ad3b0732afc63c64555fef549f8bb1">cv::getDerivKernels</a> (CV_OUT Mat &amp;kx, CV_OUT Mat &amp;ky, int dx, int dy, int ksize, bool normalize=false, int ktype=CV_32F)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">initializes kernels of the generalized Sobel operator  <a href="#a90ad3b0732afc63c64555fef549f8bb1"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">CV_EXPORTS_W Mat&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacecv.html#a38a8ea387cfb178559ad3fc4b3fd6c80">cv::getGaussianKernel</a> (int ksize, double sigma, int ktype=CV_64F)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">returns the Gaussian kernel with the specified parameters  <a href="#a38a8ea387cfb178559ad3fc4b3fd6c80"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacecv.html#a34c84c845a9c3b1b39ebca0f054e985f">cv::getKernelType</a> (const Mat &amp;kernel, Point anchor)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">returns type (one of KERNEL_*) of 1D or 2D kernel specified by its coefficients.  <a href="#a34c84c845a9c3b1b39ebca0f054e985f"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">Ptr&lt; BaseColumnFilter &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacecv.html#a2f3782d51227c04067849734cf4b82ce">cv::getLinearColumnFilter</a> (int bufType, int dstType, const Mat &amp;kernel, int anchor, int symmetryType, double delta=0, int bits=0)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">returns the primitive column filter with the specified kernel  <a href="#a2f3782d51227c04067849734cf4b82ce"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">Ptr&lt; BaseFilter &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacecv.html#ad81f0eedd6cf47677181818c49e57e9d">cv::getLinearFilter</a> (int srcType, int dstType, const Mat &amp;kernel, Point anchor=Point(-1,-1), double delta=0, int bits=0)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">returns 2D filter with the specified kernel  <a href="#ad81f0eedd6cf47677181818c49e57e9d"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">Ptr&lt; BaseRowFilter &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacecv.html#a18e4cd3f5d13f351856ac7bcf4775ed3">cv::getLinearRowFilter</a> (int srcType, int bufType, const Mat &amp;kernel, int anchor, int symmetryType)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">returns the primitive row filter with the specified kernel  <a href="#a18e4cd3f5d13f351856ac7bcf4775ed3"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">Ptr&lt; BaseColumnFilter &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacecv.html#a815b76315c43af9711335113561b6897">cv::getMorphologyColumnFilter</a> (int op, int type, int ksize, int anchor=-1)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">returns vertical 1D morphological filter  <a href="#a815b76315c43af9711335113561b6897"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">Ptr&lt; BaseFilter &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacecv.html#ab1ffcab4d220aa19881e010ad837cc6d">cv::getMorphologyFilter</a> (int op, int type, const Mat &amp;kernel, Point anchor=Point(-1,-1))</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">returns 2D morphological filter  <a href="#ab1ffcab4d220aa19881e010ad837cc6d"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">Ptr&lt; BaseRowFilter &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacecv.html#a71887cfafe1d6a6e11775183f0733031">cv::getMorphologyRowFilter</a> (int op, int type, int ksize, int anchor=-1)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">returns horizontal 1D morphological filter  <a href="#a71887cfafe1d6a6e11775183f0733031"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">Mat&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacecv.html#a8c1ae0e3589a9d77fffc962c49b22043">cv::getPerspectiveTransform</a> (const Point2f src[], const Point2f dst[])</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">returns 3x3 perspective transformation for the corresponding 4 point pairs.  <a href="#a8c1ae0e3589a9d77fffc962c49b22043"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">CV_EXPORTS_W void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacecv.html#aa6b444623fd5c569229a68f9437912bc">cv::getRectSubPix</a> (const Mat &amp;image, Size patchSize, Point2f center, CV_OUT Mat &amp;patch, int patchType=-1)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">extracts rectangle from the image at sub-pixel location  <a href="#aa6b444623fd5c569229a68f9437912bc"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">CV_EXPORTS_W Mat&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacecv.html#acaabee641f2a4a17d3836e2747866796">cv::getRotationMatrix2D</a> (Point2f center, double angle, double scale)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">returns 2x3 affine transformation matrix for the planar rotation.  <a href="#acaabee641f2a4a17d3836e2747866796"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">Ptr&lt; BaseRowFilter &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacecv.html#a0a87dad74adcd8db79fbb0a5387a6ea2">cv::getRowSumFilter</a> (int srcType, int sumType, int ksize, int anchor=-1)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">returns horizontal 1D box filter  <a href="#a0a87dad74adcd8db79fbb0a5387a6ea2"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">CV_EXPORTS_W Mat&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacecv.html#a37a6222e3e71b3c570d1e8cbb4582798">cv::getStructuringElement</a> (int shape, Size ksize, Point anchor=Point(-1,-1))</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">returns structuring element of the specified shape and size  <a href="#a37a6222e3e71b3c570d1e8cbb4582798"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">CV_EXPORTS_W void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacecv.html#a1f3ed682bf1ed43971ebf5ddb69fc915">cv::goodFeaturesToTrack</a> (const Mat &amp;image, CV_OUT vector&lt; Point2f &gt; &amp;corners, int maxCorners, double qualityLevel, double minDistance, const Mat &amp;mask=Mat(), int blockSize=3, bool useHarrisDetector=false, double k=0.04)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">finds the strong enough corners where the <a class="el" href="namespacecv.html#a2cfad4530143fae716a3bc8edf042ceb" title="computes minimum eigen value of 2x2 derivative covariation matrix at each pixel - the cornerness crit...">cornerMinEigenVal()</a> or <a class="el" href="namespacecv.html#a3e8d4390885e0a7bb45d74882c9d3b00" title="computes Harris cornerness criteria at each image pixel">cornerHarris()</a> report the local maxima  <a href="#a1f3ed682bf1ed43971ebf5ddb69fc915"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">CV_EXPORTS_W void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacecv.html#ab63de82ffa3b041456c5649d55e2c875">cv::grabCut</a> (const Mat &amp;img, Mat &amp;mask, Rect rect, Mat &amp;bgdModel, Mat &amp;fgdModel, int iterCount, int mode=GC_EVAL)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">segments the image using GrabCut algorithm  <a href="#ab63de82ffa3b041456c5649d55e2c875"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacecv.html#ab001db45c1f1af6cbdbe64df04c4e944">cv::HuMoments</a> (const Moments &amp;moments, double hu[7])</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">computes 7 Hu invariants from the moments  <a href="#ab001db45c1f1af6cbdbe64df04c4e944"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">CV_EXPORTS_W void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacecv.html#a5ec060f517074647e35a24ba95d689ff">cv::initUndistortRectifyMap</a> (const Mat &amp;cameraMatrix, const Mat &amp;distCoeffs, const Mat &amp;R, const Mat &amp;newCameraMatrix, Size size, int m1type, CV_OUT Mat &amp;map1, CV_OUT Mat &amp;map2)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">initializes maps for <a class="el" href="namespacecv.html#aa68401bf1ab93acabbcc4fb75471661a" title="warps the image using the precomputed maps. The maps are stored in either floating-point or integer f...">cv::remap()</a> to correct lens distortion and optionally rectify the image  <a href="#a5ec060f517074647e35a24ba95d689ff"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">CV_EXPORTS_W float&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacecv.html#a85e18c928575bab8d0f8dcb1243769be">cv::initWideAngleProjMap</a> (const Mat &amp;cameraMatrix, const Mat &amp;distCoeffs, Size imageSize, int destImageWidth, int m1type, CV_OUT Mat &amp;map1, CV_OUT Mat &amp;map2, int projType=PROJ_SPHERICAL_EQRECT, double alpha=0)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">initializes maps for <a class="el" href="namespacecv.html#aa68401bf1ab93acabbcc4fb75471661a" title="warps the image using the precomputed maps. The maps are stored in either floating-point or integer f...">cv::remap()</a> for wide-angle  <a href="#a85e18c928575bab8d0f8dcb1243769be"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">CV_EXPORTS_W void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacecv.html#a92e93792b18023bc02e6f480e56c67a3">cv::inpaint</a> (const Mat &amp;src, const Mat &amp;inpaintMask, CV_OUT Mat &amp;dst, double inpaintRange, int <a class="el" href="highgui__c_8h.html#a537e9e30547f68fff6358cc410095bb9">flags</a>)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">restores the damaged image areas using one of the available intpainting algorithms  <a href="#a92e93792b18023bc02e6f480e56c67a3"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">CV_EXPORTS_W void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacecv.html#a4d0084c0d29a0e5d0ff79539a84f7ca3">cv::integral</a> (const Mat &amp;src, CV_OUT Mat &amp;sum, int sdepth=-1)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">computes the integral image  <a href="#a4d0084c0d29a0e5d0ff79539a84f7ca3"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">CV_EXPORTS_W void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacecv.html#acae048a15823e4348b798a0bf3c0d7a3">cv::invertAffineTransform</a> (const Mat &amp;M, CV_OUT Mat &amp;iM)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">computes 2x3 affine transformation matrix that is inverse to the specified 2x3 affine transformation.  <a href="#acae048a15823e4348b798a0bf3c0d7a3"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">CV_EXPORTS_W bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacecv.html#add33f2d09508e57938460f8e21c11a49">cv::isContourConvex</a> (const Mat &amp;contour)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">returns true iff the contour is convex. Does not support contours with self-intersection  <a href="#add33f2d09508e57938460f8e21c11a49"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">CV_EXPORTS_W double&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacecv.html#ac0ecb84b6dbf8c28d8e999fc3a772319">cv::matchShapes</a> (const Mat &amp;contour1, const Mat &amp;contour2, int method, double parameter)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">matches two contours using one of the available algorithms  <a href="#ac0ecb84b6dbf8c28d8e999fc3a772319"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">CV_EXPORTS_W void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacecv.html#a60dfcd25bcef8dc6fb3622c9d0138695">cv::matchTemplate</a> (const Mat &amp;image, const Mat &amp;templ, CV_OUT Mat &amp;result, int method)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">computes the proximity map for the raster template and the image where the template is searched for  <a href="#a60dfcd25bcef8dc6fb3622c9d0138695"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">CV_EXPORTS_W void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacecv.html#aded76c129334e9b44188cb612c9d0115">cv::medianBlur</a> (const Mat &amp;src, CV_OUT Mat &amp;dst, int ksize)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">smooths the image using median filter.  <a href="#aded76c129334e9b44188cb612c9d0115"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">CV_EXPORTS_W RotatedRect&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacecv.html#aca1d5b4f4ee8b6d09e61a0632794b43e">cv::minAreaRect</a> (const Mat &amp;points)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">computes the minimal rotated rectangle for a set of points  <a href="#aca1d5b4f4ee8b6d09e61a0632794b43e"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">CV_EXPORTS_W void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacecv.html#a582106895b17dcd187bc64c115291cdf">cv::minEnclosingCircle</a> (const Mat &amp;points, Point2f &amp;center, float &amp;radius)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">computes the minimal enclosing circle for a set of points  <a href="#a582106895b17dcd187bc64c115291cdf"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">CV_EXPORTS_W Moments&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacecv.html#abb8450066a185c6e6eaa638c7c33504a">cv::moments</a> (const Mat &amp;array, bool binaryImage=false)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">computes moments of the rasterized shape or a vector of points  <a href="#abb8450066a185c6e6eaa638c7c33504a"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">CV_EXPORTS_W void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacecv.html#a6982d67ad995ade6ec2f0567f4a90386">cv::morphologyEx</a> (const Mat &amp;src, CV_OUT Mat &amp;dst, int op, const Mat &amp;kernel, Point anchor=Point(-1,-1), int iterations=1, int borderType=BORDER_CONSTANT, const Scalar &amp;borderValue=morphologyDefaultBorderValue())</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">applies an advanced morphological operation to the image  <a href="#a6982d67ad995ade6ec2f0567f4a90386"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">CV_EXPORTS_W double&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacecv.html#adac47de4e397d66f744a8b8548412f3a">cv::pointPolygonTest</a> (const Mat &amp;contour, Point2f pt, bool measureDist)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">checks if the point is inside the contour. Optionally computes the signed distance from the point to the contour boundary  <a href="#adac47de4e397d66f744a8b8548412f3a"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">CV_EXPORTS_W void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacecv.html#ab4921281b9e70f749e721ab57c2d25b3">cv::preCornerDetect</a> (const Mat &amp;src, CV_OUT Mat &amp;dst, int ksize, int borderType=BORDER_DEFAULT)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">computes another complex cornerness criteria at each pixel  <a href="#ab4921281b9e70f749e721ab57c2d25b3"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">CV_EXPORTS_W void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacecv.html#a29689a8c0bb345ee796ffff501e11e1b">cv::pyrDown</a> (const Mat &amp;src, CV_OUT Mat &amp;dst, const Size &amp;dstsize=Size())</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">smooths and downsamples the image  <a href="#a29689a8c0bb345ee796ffff501e11e1b"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">CV_EXPORTS_W void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacecv.html#a6ad3c4bf3fc8d516b9256d43efb3c642">cv::pyrMeanShiftFiltering</a> (const Mat &amp;src, CV_OUT Mat &amp;dst, double sp, double sr, int maxLevel=1, TermCriteria termcrit=TermCriteria(TermCriteria::MAX_ITER+TermCriteria::EPS, 5, 1))</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">filters image using meanshift algorithm  <a href="#a6ad3c4bf3fc8d516b9256d43efb3c642"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">CV_EXPORTS_W void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacecv.html#ae296e58e135a232426bc7ae4a396d0e6">cv::pyrUp</a> (const Mat &amp;src, CV_OUT Mat &amp;dst, const Size &amp;dstsize=Size())</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">upsamples and smoothes the image  <a href="#ae296e58e135a232426bc7ae4a396d0e6"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">CV_EXPORTS_W void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacecv.html#aa68401bf1ab93acabbcc4fb75471661a">cv::remap</a> (const Mat &amp;src, CV_OUT Mat &amp;dst, const Mat &amp;map1, const Mat &amp;map2, int interpolation, int borderMode=BORDER_CONSTANT, const Scalar &amp;borderValue=Scalar())</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">warps the image using the precomputed maps. The maps are stored in either floating-point or integer fixed-point format  <a href="#aa68401bf1ab93acabbcc4fb75471661a"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">CV_EXPORTS_W void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacecv.html#a121d446fc690770a533e29073af347cb">cv::resize</a> (const Mat &amp;src, CV_OUT Mat &amp;dst, Size dsize, double fx=0, double fy=0, int interpolation=INTER_LINEAR)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">resizes the image  <a href="#a121d446fc690770a533e29073af347cb"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">CV_EXPORTS_W void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacecv.html#a2b442e93b5abfe8729a3736172816662">cv::sepFilter2D</a> (const Mat &amp;src, CV_OUT Mat &amp;dst, int ddepth, const Mat &amp;kernelX, const Mat &amp;kernelY, Point anchor=Point(-1,-1), double delta=0, int borderType=BORDER_DEFAULT)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">applies separable 2D linear filter to the image  <a href="#a2b442e93b5abfe8729a3736172816662"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">CV_EXPORTS_W double&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacecv.html#a0e187bb0c94a8828c93c41d29874a12d">cv::threshold</a> (const Mat &amp;src, CV_OUT Mat &amp;dst, double thresh, double maxval, int type)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">applies fixed threshold to the image  <a href="#a0e187bb0c94a8828c93c41d29874a12d"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">CV_EXPORTS_W void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacecv.html#acd2791332bd6bc0bfa5ab142403ccee5">cv::undistort</a> (const Mat &amp;src, CV_OUT Mat &amp;dst, const Mat &amp;cameraMatrix, const Mat &amp;distCoeffs, const Mat &amp;newCameraMatrix=Mat())</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">corrects lens distortion for the given camera matrix and distortion coefficients  <a href="#acd2791332bd6bc0bfa5ab142403ccee5"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacecv.html#a25c0ec7b848260958a4fad34cf9efb0a">cv::undistortPoints</a> (const Mat &amp;src, CV_OUT vector&lt; Point2f &gt; &amp;dst, const Mat &amp;cameraMatrix, const Mat &amp;distCoeffs, const Mat &amp;R=Mat(), const Mat &amp;P=Mat())</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">returns points' coordinates after lens distortion correction  <a href="#a25c0ec7b848260958a4fad34cf9efb0a"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">CV_EXPORTS_W void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacecv.html#ac86163eefe3021cf8a408fdbb7d2bc07">cv::undistortPoints</a> (const Mat &amp;src, CV_OUT Mat &amp;dst, const Mat &amp;cameraMatrix, const Mat &amp;distCoeffs, const Mat &amp;R=Mat(), const Mat &amp;P=Mat())</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">returns points' coordinates after lens distortion correction  <a href="#ac86163eefe3021cf8a408fdbb7d2bc07"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">CV_EXPORTS_W void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacecv.html#ac2c1ea39fee326afe10156060aad58e4">cv::warpAffine</a> (const Mat &amp;src, CV_OUT Mat &amp;dst, const Mat &amp;M, Size dsize, int <a class="el" href="highgui__c_8h.html#a537e9e30547f68fff6358cc410095bb9">flags</a>=INTER_LINEAR, int borderMode=BORDER_CONSTANT, const Scalar &amp;borderValue=Scalar())</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">warps the image using affine transformation  <a href="#ac2c1ea39fee326afe10156060aad58e4"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">CV_EXPORTS_W void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacecv.html#abcb136a8ee6ee99e27b655c0c271e7bd">cv::warpPerspective</a> (const Mat &amp;src, CV_OUT Mat &amp;dst, const Mat &amp;M, Size dsize, int <a class="el" href="highgui__c_8h.html#a537e9e30547f68fff6358cc410095bb9">flags</a>=INTER_LINEAR, int borderMode=BORDER_CONSTANT, const Scalar &amp;borderValue=Scalar())</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">warps the image using perspective transformation  <a href="#abcb136a8ee6ee99e27b655c0c271e7bd"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">CV_EXPORTS_W void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacecv.html#a1bb6e19ae54ce6d07bdbe8fe3c43d246">cv::watershed</a> (const Mat &amp;image, Mat &amp;markers)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">segments the image using watershed algorithm  <a href="#a1bb6e19ae54ce6d07bdbe8fe3c43d246"></a><br/></td></tr>
<tr><td colspan="2"><h2><a name="var-members"></a>
Variables</h2></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">CV_OUT Mat double double int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacecv.html#ad0098ecf61ebe71b64fa256409201476">cv::apertureSize</a> = 3</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">CV_OUT Mat Size double double int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacecv.html#a16f107159242c6808fec2bedfdb18068">cv::borderType</a> = BORDER_DEFAULT )</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">CV_OUT vector&lt; Vec3f &gt; &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacecv.html#a364450dcb886e242562de250185860c5">cv::circles</a></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">CV_OUT Mat int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacecv.html#a0f0016b2c017b8d68b6acf82b36cbd4b">cv::ddepth</a></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">CV_OUT Mat int int int int <br class="typebreak"/>
double double&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacecv.html#ae24d37246741581c81cb1f207b107421">cv::delta</a> = 0</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">CV_OUT vector&lt; Vec3f &gt; int double&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacecv.html#a59acee9b09f8622af0802f2fc4db445a">cv::dp</a></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">CV_OUT Mat &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacecv.html#a59214726abd6b631224a69d3e82d6999">cv::dst</a></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">CV_OUT Mat int int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacecv.html#a4658fd39a855329aac65033733119205">cv::dx</a></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">CV_OUT Mat int int int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacecv.html#a36551c3333139ab4d10384ed0c9d773f">cv::dy</a></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">CV_OUT Mat &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacecv.html#a9c802e1bc7abb927ae92a9b4b04e836e">cv::edges</a></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">Mat Point Scalar CV_OUT Rect <br class="typebreak"/>
Scalar Scalar int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacecv.html#ab2b99c0025a4b5ea3434d063e02fc9b4">cv::flags</a> = 4 )</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">CV_OUT Mat Size&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacecv.html#ab0f741e87214c4e98fbd767b4ce05d22">cv::ksize</a> = 3</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">CV_OUT Mat double double int bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacecv.html#a993fa4408330297880b3fec0c1946205">cv::L2gradient</a> = false )</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">CV_OUT vector&lt; Vec2f &gt; &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacecv.html#a624851fbca494f3cdf2bc5b61f4e2a29">cv::lines</a></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">Mat Point Scalar CV_OUT Rect Scalar&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacecv.html#af7ce25850f197c5bcf75a0a4b4292c5f">cv::loDiff</a> = Scalar()</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">Mat &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacecv.html#a2efcf76b229625667f9c282f913f7d07">cv::mask</a></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">CV_OUT vector&lt; Vec4i &gt; double <br class="typebreak"/>
double int double double&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacecv.html#a6407e6b7d9031e55c4b50d7b1e1ebdfd">cv::maxLineGap</a> = 0 )</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">CV_OUT vector&lt; Vec3f &gt; int <br class="typebreak"/>
double double double double <br class="typebreak"/>
int int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacecv.html#ae9fb6eb5d5fa17bfb0d5c31dd21b174f">cv::maxRadius</a> = 0 )</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">CV_OUT vector&lt; Vec3f &gt; int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacecv.html#a4df92ae5110d3034ca8df254752f404e">cv::method</a> = 0</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">CV_OUT vector&lt; Vec3f &gt; int <br class="typebreak"/>
double double&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacecv.html#a7c0d656aa81059461af7245b7cc2b452">cv::minDist</a></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">CV_OUT vector&lt; Vec4i &gt; double <br class="typebreak"/>
double int double&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacecv.html#a37f7b9f1e529be1f4e04c9230ffab706">cv::minLineLength</a> = 0</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">CV_OUT vector&lt; Vec3f &gt; int <br class="typebreak"/>
double double double double <br class="typebreak"/>
int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacecv.html#a2c432f81377c7a267826a329b37069ba">cv::minRadius</a> = 0</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">Mat Point Scalar&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacecv.html#a9fecd3bb2555acaf33eae2f09c7d0e28">cv::newVal</a></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">CV_OUT vector&lt; Vec3f &gt; int <br class="typebreak"/>
double double double&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacecv.html#aa9317dae07aeb98a821f3b148a5419a6">cv::param1</a> = 100</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">CV_OUT vector&lt; Vec3f &gt; int <br class="typebreak"/>
double double double double&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacecv.html#a4619379995be260fe90f24f90d5dc1a5">cv::param2</a> = 100</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">Mat Point Scalar CV_OUT Rect *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacecv.html#af81ea5e0535f1932372616469864dbee">cv::rect</a> = 0</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">CV_OUT vector&lt; Vec2f &gt; double&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacecv.html#ad25c9f034324541b14a99e7241c9236b">cv::rho</a></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">CV_OUT Mat int int int int double&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacecv.html#a51a22470a6038d4d737a633730006770">cv::scale</a> = 1</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">CV_OUT Mat CV_OUT Mat int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacecv.html#a1a2be6327ca5796c0a0fb40c45043ba5">cv::sdepth</a> = -1 )</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">Mat Point&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacecv.html#ade3474cf5fc7a1193bbc15de2b037a8d">cv::seedPoint</a></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">CV_OUT Mat Size double&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacecv.html#af9d7f6b20fa6abe1036441a9b2accb81">cv::sigma1</a></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">CV_OUT Mat Size double double&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacecv.html#a09e33ed647d93a548271117fb3e7f731">cv::sigma2</a> = 0</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">CV_OUT Mat CV_OUT Mat &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacecv.html#ad0beb31b26312a5f9df0da5e24f75524">cv::sqsum</a></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">CV_OUT vector&lt; Vec2f &gt; double <br class="typebreak"/>
double int double&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacecv.html#a5c23a177aad49753bd7a476055365248">cv::srn</a> = 0</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">CV_OUT vector&lt; Vec2f &gt; double <br class="typebreak"/>
double int double double&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacecv.html#a46c0ff8efe68ae7d7302f934a0d6c14e">cv::stn</a> = 0 )</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">CV_OUT Mat &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacecv.html#a812b04b300feed9639f49480260137c4">cv::sum</a></td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">computes sum of array elements  <a href="#a812b04b300feed9639f49480260137c4"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">CV_OUT vector&lt; Vec2f &gt; double <br class="typebreak"/>
double&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacecv.html#a2803266947a08c4e73450fa450bdca35">cv::theta</a></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">CV_OUT vector&lt; Vec2f &gt; double <br class="typebreak"/>
double int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacecv.html#aad4b13bcee0029196e54d61c2f928a12">cv::threshold</a></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">CV_OUT Mat double&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacecv.html#a942ee638abd261f10423976f5c7e8f41">cv::threshold1</a></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">CV_OUT Mat double double&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacecv.html#a8711cd9fb1146c3c97dd3407b1bb2937">cv::threshold2</a></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">CV_OUT Mat CV_OUT Mat CV_OUT Mat &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacecv.html#a560aa732b6fdf9b4d84696e8db46e834">cv::tilted</a></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">Mat Point Scalar CV_OUT Rect <br class="typebreak"/>
Scalar Scalar&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacecv.html#aad7cd47738db7dd1745d25f9cee802aa">cv::upDiff</a> = Scalar()</td></tr>
</table>
<hr/><a name="details" id="details"></a><h2>Detailed Description</h2>
<div class="textblock"><p>The Image Processing. </p>
</div></div>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
<a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(0)"><span class="SelectionMark">&#160;</span>All</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(1)"><span class="SelectionMark">&#160;</span>Classes</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(2)"><span class="SelectionMark">&#160;</span>Namespaces</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(3)"><span class="SelectionMark">&#160;</span>Files</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(4)"><span class="SelectionMark">&#160;</span>Functions</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(5)"><span class="SelectionMark">&#160;</span>Variables</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(6)"><span class="SelectionMark">&#160;</span>Typedefs</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(7)"><span class="SelectionMark">&#160;</span>Enumerations</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(8)"><span class="SelectionMark">&#160;</span>Enumerator</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(9)"><span class="SelectionMark">&#160;</span>Friends</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(10)"><span class="SelectionMark">&#160;</span>Defines</a></div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<hr class="footer"/><address class="footer"><small>Generated on Wed Mar 28 2012 16:15:17 for opencv by&#160;
<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/></a> 1.7.4 </small></address>
</body>
</html>
